<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<doc>
  <assembly>
    <name>Rhino.Mocks</name>
  </assembly>
  <members>
    <member name="T:Rhino.Mocks.BackToRecordOptions">
      <summary>
            What should BackToRecord clear
            </summary>
    </member>
    <member name="F:Rhino.Mocks.BackToRecordOptions.None">
      <summary>
            Nothing
            </summary>
    </member>
    <member name="F:Rhino.Mocks.BackToRecordOptions.EventSubscribers">
      <summary>
            Event subscribers for this instance
            </summary>
    </member>
    <member name="F:Rhino.Mocks.BackToRecordOptions.OriginalMethodsToCall">
      <summary>
            Methods that should be forwarded to the base class implementation
            </summary>
    </member>
    <member name="F:Rhino.Mocks.BackToRecordOptions.PropertyBehavior">
      <summary>
            Properties that should behave like properties
            </summary>
    </member>
    <member name="F:Rhino.Mocks.BackToRecordOptions.All">
      <summary>
            Remove al the behavior of the object
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Constraints.AbstractConstraint">
      <summary>
            Interface for constraints
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.AbstractConstraint.Eval(System.Object)">
      <summary>
            determains if the object pass the constraints
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.AbstractConstraint.op_BitwiseAnd(Rhino.Mocks.Constraints.AbstractConstraint,Rhino.Mocks.Constraints.AbstractConstraint)">
      <summary>
            And operator for constraints
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.AbstractConstraint.op_LogicalNot(Rhino.Mocks.Constraints.AbstractConstraint)">
      <summary>
            Not operator for constraints
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.AbstractConstraint.op_BitwiseOr(Rhino.Mocks.Constraints.AbstractConstraint,Rhino.Mocks.Constraints.AbstractConstraint)">
      <summary>
            Or operator for constraints
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.AbstractConstraint.op_False(Rhino.Mocks.Constraints.AbstractConstraint)">
      <summary>
            Allow overriding of || or &amp;&amp;
            </summary>
      <param name="c">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Rhino.Mocks.Constraints.AbstractConstraint.op_True(Rhino.Mocks.Constraints.AbstractConstraint)">
      <summary>
            Allow overriding of || or &amp;&amp;
            </summary>
      <param name="c">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Rhino.Mocks.Constraints.AbstractConstraint.Message">
      <summary>
            Gets the message for this constraint
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Rhino.Mocks.Constraints.PublicFieldConstraint">
      <summary>
            Constrain that the public field matches another constraint.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.PublicFieldConstraint.#ctor(System.String,Rhino.Mocks.Constraints.AbstractConstraint)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Constraints.PublicFieldConstraint" /> instance.
            </summary>
      <param name="publicFieldName">Name of the public field.</param>
      <param name="constraint">Constraint to place on the public field value.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.PublicFieldConstraint.#ctor(System.Type,System.String,Rhino.Mocks.Constraints.AbstractConstraint)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Constraints.PublicFieldConstraint" /> instance, specifying a disambiguating
            <paramref name="declaringType" /> for the public field.
            </summary>
      <param name="declaringType">The type that declares the public field, used to disambiguate between public fields.</param>
      <param name="publicFieldName">Name of the public field.</param>
      <param name="constraint">Constraint to place on the public field value.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.PublicFieldConstraint.Eval(System.Object)">
      <summary>
            Determines if the object passes the constraint.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Constraints.PublicFieldConstraint.Message">
      <summary>
            Gets the message for this constraint
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Rhino.Mocks.Constraints.PublicFieldIs">
      <summary>
            Constrain that the public field has a specified value
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.PublicFieldIs.#ctor(System.String,System.Object)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Constraints.PublicFieldIs" /> instance.
            </summary>
      <param name="publicFieldName">Name of the public field.</param>
      <param name="expectedValue">Expected value.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.PublicFieldIs.#ctor(System.Type,System.String,System.Object)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Constraints.PublicFieldIs" /> instance, specifying a disambiguating
            <paramref name="declaringType" /> for the public field.
            </summary>
      <param name="declaringType">The type that declares the public field, used to disambiguate between public fields.</param>
      <param name="publicFieldName">Name of the public field.</param>
      <param name="expectedValue">Expected value.</param>
    </member>
    <member name="T:Rhino.Mocks.Constraints.PropertyConstraint">
      <summary>
            Constrain that the property matches another constraint.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.PropertyConstraint.#ctor(System.String,Rhino.Mocks.Constraints.AbstractConstraint)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Constraints.PropertyConstraint" /> instance.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <param name="constraint">Constraint to place on the property value.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.PropertyConstraint.#ctor(System.Type,System.String,Rhino.Mocks.Constraints.AbstractConstraint)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Constraints.PropertyConstraint" /> instance, specifying a disambiguating
            <paramref name="declaringType" /> for the property.
            </summary>
      <param name="declaringType">The type that declares the property, used to disambiguate between properties.</param>
      <param name="propertyName">Name of the property.</param>
      <param name="constraint">Constraint to place on the property value.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.PropertyConstraint.Eval(System.Object)">
      <summary>
            Determines if the object passes the constraint.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Constraints.PropertyConstraint.Message">
      <summary>
            Gets the message for this constraint
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Rhino.Mocks.Constraints.PropertyIs">
      <summary>
            Constrain that the property has a specified value
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.PropertyIs.#ctor(System.String,System.Object)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Constraints.PropertyIs" /> instance.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <param name="expectedValue">Expected value.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.PropertyIs.#ctor(System.Type,System.String,System.Object)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Constraints.PropertyIs" /> instance, specifying a disambiguating
            <paramref name="declaringType" /> for the property.
            </summary>
      <param name="declaringType">The type that declares the property, used to disambiguate between properties.</param>
      <param name="propertyName">Name of the property.</param>
      <param name="expectedValue">Expected value.</param>
    </member>
    <member name="T:Rhino.Mocks.Constraints.TypeOf">
      <summary>
            Constrain that the parameter must be of the specified type
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.TypeOf.#ctor(System.Type)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Constraints.TypeOf" /> instance.
            </summary>
      <param name="type">Type.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.TypeOf.Eval(System.Object)">
      <summary>
            determains if the object pass the constraints
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Constraints.TypeOf.Message">
      <summary>
            Gets the message for this constraint
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Rhino.Mocks.Constraints.Same">
      <summary>
            Constraint that determines whether an object is the same object as another.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Same.#ctor(System.Object)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Constraints.Equal" /> instance.
            </summary>
      <param name="obj">Obj.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Same.Eval(System.Object)">
      <summary>
            Determines if the object passes the constraints.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Constraints.Same.Message">
      <summary>
            Gets the message for this constraint.
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Constraints.PredicateConstraint`1">
      <summary>
            Evaluate a parameter using constraints
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.PredicateConstraint`1.#ctor(System.Predicate{`0})">
      <summary>
            Create new instance 
            </summary>
      <param name="predicate">
      </param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.PredicateConstraint`1.Eval(System.Object)">
      <summary>
            determains if the object pass the constraints
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Constraints.PredicateConstraint`1.Message">
      <summary>
            Gets the message for this constraint
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Rhino.Mocks.Constraints.CollectionEqual">
      <summary>
            Constrain that the list contains the same items as the parameter list
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.CollectionEqual.#ctor(System.Collections.IEnumerable)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Constraints.CollectionEqual" /> instance.
            </summary>
      <param name="collection">In list.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.CollectionEqual.Eval(System.Object)">
      <summary>
            determains if the object pass the constraints
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Constraints.CollectionEqual.Message">
      <summary>
            Gets the message for this constraint
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Rhino.Mocks.Constraints.OneOf">
      <summary>
            Constrain that the parameter is one of the items in the list
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.OneOf.#ctor(System.Collections.IEnumerable)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Constraints.OneOf" /> instance.
            </summary>
      <param name="collection">In list.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.OneOf.Eval(System.Object)">
      <summary>
            determains if the object pass the constraints
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Constraints.OneOf.Message">
      <summary>
            Gets the message for this constraint
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Rhino.Mocks.Constraints.IsIn">
      <summary>
            Constrain that the object is inside the parameter list
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.IsIn.#ctor(System.Object)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Constraints.IsIn" /> instance.
            </summary>
      <param name="inList">In list.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.IsIn.Eval(System.Object)">
      <summary>
            determains if the object pass the constraints
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Constraints.IsIn.Message">
      <summary>
            Gets the message for this constraint
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Rhino.Mocks.Constraints.CollectionCount">
      <summary>
            Applies another AbstractConstraint to the collection count.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.CollectionCount.#ctor(Rhino.Mocks.Constraints.AbstractConstraint)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Constraints.CollectionCount" /> instance.
            </summary>
      <param name="constraint">The constraint that should be applied to the collection count.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.CollectionCount.Eval(System.Object)">
      <summary>
            Determines if the parameter conforms to this constraint.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Constraints.CollectionCount.Message">
      <summary>
            Gets the message for this constraint.
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Constraints.ListElement">
      <summary>
            Applies another AbstractConstraint to a specific list element.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.ListElement.#ctor(System.Int32,Rhino.Mocks.Constraints.AbstractConstraint)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Constraints.ListElement" /> instance.
            </summary>
      <param name="index">The zero-based index of the list element.</param>
      <param name="constraint">The constraint that should be applied to the list element.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.ListElement.Eval(System.Object)">
      <summary>
            Determines if the parameter conforms to this constraint.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Constraints.ListElement.Message">
      <summary>
            Gets the message for this constraint
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Rhino.Mocks.Constraints.Or">
      <summary>
            Combines two constraints, constraint pass if either is fine.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Or.#ctor(Rhino.Mocks.Constraints.AbstractConstraint,Rhino.Mocks.Constraints.AbstractConstraint)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Constraints.And" /> instance.
            </summary>
      <param name="c1">C1.</param>
      <param name="c2">C2.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Or.Eval(System.Object)">
      <summary>
            determains if the object pass the constraints
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Constraints.Or.Message">
      <summary>
            Gets the message for this constraint
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Rhino.Mocks.Constraints.Not">
      <summary>
            Negate a constraint
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Not.#ctor(Rhino.Mocks.Constraints.AbstractConstraint)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Constraints.And" /> instance.
            </summary>
      <param name="c1">C1.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Not.Eval(System.Object)">
      <summary>
            determains if the object pass the constraints
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Constraints.Not.Message">
      <summary>
            Gets the message for this constraint
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Rhino.Mocks.Constraints.And">
      <summary>
            Combines two constraints
            </summary>
      <remarks>
      </remarks>
    </member>
    <member name="M:Rhino.Mocks.Constraints.And.#ctor(Rhino.Mocks.Constraints.AbstractConstraint,Rhino.Mocks.Constraints.AbstractConstraint)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Constraints.And" /> instance.
            </summary>
      <param name="c1">C1.</param>
      <param name="c2">C2.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.And.Eval(System.Object)">
      <summary>
            determains if the object pass the constraints
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Constraints.And.Message">
      <summary>
            Gets the message for this constraint
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Rhino.Mocks.Constraints.Like">
      <summary>
            Constrain the argument to validate according to regex pattern
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Like.#ctor(System.String)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Constraints.Like" /> instance.
            </summary>
      <param name="pattern">Pattern.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Like.Eval(System.Object)">
      <summary>
            determains if the object pass the constraints
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Constraints.Like.Message">
      <summary>
            Gets the message for this constraint
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Rhino.Mocks.Constraints.Contains">
      <summary>
            Constraint that evaluate whatever an argument contains the specified string.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Contains.#ctor(System.String)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Constraints.Contains" /> instance.
            </summary>
      <param name="innerString">Inner string.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Contains.Eval(System.Object)">
      <summary>
            determains if the object pass the constraints
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Constraints.Contains.Message">
      <summary>
            Gets the message for this constraint
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Rhino.Mocks.Constraints.EndsWith">
      <summary>
            Constraint that evaluate whatever an argument ends with the specified string
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.EndsWith.#ctor(System.String)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Constraints.EndsWith" /> instance.
            </summary>
      <param name="end">End.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.EndsWith.Eval(System.Object)">
      <summary>
            determains if the object pass the constraints
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Constraints.EndsWith.Message">
      <summary>
            Gets the message for this constraint
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Rhino.Mocks.Constraints.StartsWith">
      <summary>
            Constraint that evaluate whatever an argument start with the specified string
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.StartsWith.#ctor(System.String)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Constraints.StartsWith" /> instance.
            </summary>
      <param name="start">Start.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.StartsWith.Eval(System.Object)">
      <summary>
            determains if the object pass the constraints
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Constraints.StartsWith.Message">
      <summary>
            Gets the message for this constraint
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Rhino.Mocks.Constraints.Equal">
      <summary>
            Constraint that evaluate whatever an object equals another
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Equal.#ctor(System.Object)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Constraints.Equal" /> instance.
            </summary>
      <param name="obj">Obj.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Equal.Eval(System.Object)">
      <summary>
            determains if the object pass the constraints
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Constraints.Equal.Message">
      <summary>
            Gets the message for this constraint
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Rhino.Mocks.Constraints.Anything">
      <summary>
            Constraint that always returns true
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Anything.Eval(System.Object)">
      <summary>
            determains if the object pass the constraints
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Constraints.Anything.Message">
      <summary>
            Gets the message for this constraint
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Rhino.Mocks.Constraints.ComparingConstraint">
      <summary>
            Constraint that evaluate whatever a comparable is greater than another
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.ComparingConstraint.#ctor(System.IComparable,System.Boolean,System.Boolean)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Constraints.ComparingConstraint" /> instance.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.ComparingConstraint.Eval(System.Object)">
      <summary>
            determains if the object pass the constraints
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Constraints.ComparingConstraint.Message">
      <summary>
            Gets the message for this constraint
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Rhino.Mocks.Constraints.PublicField">
      <summary>
            Central location for constraints for object's public fields
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.PublicField.Value(System.String,System.Object)">
      <summary>
            Constrains the parameter to have a public field with the specified value
            </summary>
      <param name="publicFieldName">Name of the public field.</param>
      <param name="expectedValue">Expected value.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Rhino.Mocks.Constraints.PublicField.Value(System.Type,System.String,System.Object)">
      <summary>
            Constrains the parameter to have a public field with the specified value.
            </summary>
      <param name="declaringType">The type that declares the public field, used to disambiguate between public fields.</param>
      <param name="publicFieldName">Name of the public field.</param>
      <param name="expectedValue">Expected value.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Rhino.Mocks.Constraints.PublicField.ValueConstraint(System.String,Rhino.Mocks.Constraints.AbstractConstraint)">
      <summary>
            Constrains the parameter to have a public field satisfying a specified constraint.
            </summary>
      <param name="publicFieldName">Name of the public field.</param>
      <param name="publicFieldConstraint">Constraint for the public field.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.PublicField.ValueConstraint(System.Type,System.String,Rhino.Mocks.Constraints.AbstractConstraint)">
      <summary>
            Constrains the parameter to have a public field satisfying a specified constraint.
            </summary>
      <param name="declaringType">The type that declares the public field, used to disambiguate between public fields.</param>
      <param name="publicFieldName">Name of the public field.</param>
      <param name="publicFieldConstraint">Constraint for the public field.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.PublicField.IsNull(System.String)">
      <summary>
            Determines whether the parameter has the specified public field and that it is null.
            </summary>
      <param name="publicFieldName">Name of the public field.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Rhino.Mocks.Constraints.PublicField.IsNull(System.Type,System.String)">
      <summary>
            Determines whether the parameter has the specified public field and that it is null.
            </summary>
      <param name="declaringType">The type that declares the public field, used to disambiguate between public fields.</param>
      <param name="publicFieldName">Name of the public field.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Rhino.Mocks.Constraints.PublicField.IsNotNull(System.String)">
      <summary>
            Determines whether the parameter has the specified public field and that it is not null.
            </summary>
      <param name="publicFieldName">Name of the public field.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Rhino.Mocks.Constraints.PublicField.IsNotNull(System.Type,System.String)">
      <summary>
            Determines whether the parameter has the specified public field and that it is not null.
            </summary>
      <param name="declaringType">The type that declares the public field, used to disambiguate between public fields.</param>
      <param name="publicFieldName">Name of the public field.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Rhino.Mocks.Constraints.Is">
      <summary>
            Central location for constraints
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Is.GreaterThan(System.IComparable)">
      <summary>
            Evaluate a greater than constraint for <see cref="T:System.IComparable" />.
            </summary>
      <param name="objToCompare">The object the parameter should be greater than</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Is.LessThan(System.IComparable)">
      <summary>
            Evaluate a less than constraint for <see cref="T:System.IComparable" />.
            </summary>
      <param name="objToCompare">The object the parameter should be less than</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Is.LessThanOrEqual(System.IComparable)">
      <summary>
            Evaluate a less than or equal constraint for <see cref="T:System.IComparable" />.
            </summary>
      <param name="objToCompare">The object the parameter should be less than or equal to</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Is.GreaterThanOrEqual(System.IComparable)">
      <summary>
            Evaluate a greater than or equal constraint for <see cref="T:System.IComparable" />.
            </summary>
      <param name="objToCompare">The object the parameter should be greater than or equal to</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Is.Equal(System.Object)">
      <summary>
            Evaluate an equal constraint for <see cref="T:System.IComparable" />.
            </summary>
      <param name="obj">The object the parameter should equal to</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Is.NotEqual(System.Object)">
      <summary>
            Evaluate a not equal constraint for <see cref="T:System.IComparable" />.
            </summary>
      <param name="obj">The object the parameter should not equal to</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Is.Same(System.Object)">
      <summary>
            Evaluate a same as constraint.
            </summary>
      <param name="obj">The object the parameter should the same as.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Is.NotSame(System.Object)">
      <summary>
            Evaluate a not same as constraint.
            </summary>
      <param name="obj">The object the parameter should not be the same as.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Is.Anything">
      <summary>
            A constraints that accept anything
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Is.Null">
      <summary>
            A constraint that accept only nulls
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Is.NotNull">
      <summary>
            A constraint that accept only non null values
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Is.TypeOf(System.Type)">
      <summary>
            A constraint that accept only value of the specified type
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Is.TypeOf``1">
      <summary>
            A constraint that accept only value of the specified type
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Is.Matching``1(System.Predicate{``0})">
      <summary>
            Evaluate a parameter using a predicate
            </summary>
      <param name="predicate">The predicate to use</param>
    </member>
    <member name="T:Rhino.Mocks.Constraints.List">
      <summary>
            Central location for constraints about lists and collections
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.List.IsIn(System.Object)">
      <summary>
            Determines whether the specified obj is in the paramter.
            The parameter must be IEnumerable.
            </summary>
      <param name="obj">Obj.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Rhino.Mocks.Constraints.List.OneOf(System.Collections.IEnumerable)">
      <summary>
            Determains whatever the parameter is in the collection.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.List.Equal(System.Collections.IEnumerable)">
      <summary>
            Determains that the parameter collection is identical to the specified collection
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.List.Count(Rhino.Mocks.Constraints.AbstractConstraint)">
      <summary>
            Determines that the parameter collection has the specified number of elements.
            </summary>
      <param name="constraint">The constraint that should be applied to the collection count.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.List.Element(System.Int32,Rhino.Mocks.Constraints.AbstractConstraint)">
      <summary>
            Determines that an element of the parameter collections conforms to another AbstractConstraint.
            </summary>
      <param name="index">The zero-based index of the list element.</param>
      <param name="constraint">The constraint which should be applied to the list element.</param>
    </member>
    <member name="T:Rhino.Mocks.Constraints.Property">
      <summary>
            Central location for constraints for object's properties
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Property.Value(System.String,System.Object)">
      <summary>
            Constrains the parameter to have property with the specified value
            </summary>
      <param name="propertyName">Name of the property.</param>
      <param name="expectedValue">Expected value.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Property.Value(System.Type,System.String,System.Object)">
      <summary>
            Constrains the parameter to have property with the specified value.
            </summary>
      <param name="declaringType">The type that declares the property, used to disambiguate between properties.</param>
      <param name="propertyName">Name of the property.</param>
      <param name="expectedValue">Expected value.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Property.ValueConstraint(System.String,Rhino.Mocks.Constraints.AbstractConstraint)">
      <summary>
            Constrains the parameter to have a property satisfying a specified constraint.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <param name="propertyConstraint">Constraint for the property.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Property.ValueConstraint(System.Type,System.String,Rhino.Mocks.Constraints.AbstractConstraint)">
      <summary>
            Constrains the parameter to have a property satisfying a specified constraint.
            </summary>
      <param name="declaringType">The type that declares the property, used to disambiguate between properties.</param>
      <param name="propertyName">Name of the property.</param>
      <param name="propertyConstraint">Constraint for the property.</param>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Property.IsNull(System.String)">
      <summary>
            Determines whether the parameter has the specified property and that it is null.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Property.IsNull(System.Type,System.String)">
      <summary>
            Determines whether the parameter has the specified property and that it is null.
            </summary>
      <param name="declaringType">The type that declares the property, used to disambiguate between properties.</param>
      <param name="propertyName">Name of the property.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Property.IsNotNull(System.String)">
      <summary>
            Determines whether the parameter has the specified property and that it is not null.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Property.IsNotNull(System.Type,System.String)">
      <summary>
            Determines whether the parameter has the specified property and that it is not null.
            </summary>
      <param name="declaringType">The type that declares the property, used to disambiguate between properties.</param>
      <param name="propertyName">Name of the property.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Rhino.Mocks.Constraints.Text">
      <summary>
            Central location for all text related constraints
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Text.StartsWith(System.String)">
      <summary>
            Constrain the argument to starts with the specified string
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Text.EndsWith(System.String)">
      <summary>
            Constrain the argument to end with the specified string
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Text.Contains(System.String)">
      <summary>
            Constrain the argument to contain the specified string
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Constraints.Text.Like(System.String)">
      <summary>
            Constrain the argument to validate according to regex pattern
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Exceptions.ExpectationViolationException">
      <summary>
            An expectaton violation was detected.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Exceptions.ExpectationViolationException.#ctor(System.String)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Exceptions.ExpectationViolationException" /> instance.
            </summary>
      <param name="message">Message.</param>
    </member>
    <member name="M:Rhino.Mocks.Exceptions.ExpectationViolationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Serialization constructor
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Exceptions.ObjectNotMockFromThisRepositoryException">
      <summary>
            Signals that an object was call on a mock repostiroy which doesn't
            belong to this mock repository or not a mock
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Exceptions.ObjectNotMockFromThisRepositoryException.#ctor(System.String)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Exceptions.ObjectNotMockFromThisRepositoryException" /> instance.
            </summary>
      <param name="message">Message.</param>
    </member>
    <member name="M:Rhino.Mocks.Exceptions.ObjectNotMockFromThisRepositoryException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Serialization constructor
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Expect">
      <summary>
            Allows to set expectation on methods that has return values.
            For methods with void return value, you need to use LastCall
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Expect.Action">
      <summary>
             A delegate that execute an action
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Expect.Call``1(``0)">
      <summary>
            The method options for the last call on /any/ proxy on /any/ repository on the current thread.
            This method if not safe for multi threading scenarios, use <see cref="M:Rhino.Mocks.Expect.On(System.Object)" />.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Expect.Call(Rhino.Mocks.Expect.Action)">
      <summary>
            Accepts a delegate that will execute inside the method, and then return the resulting
            <see cref="T:Rhino.Mocks.Interfaces.IMethodOptions`1" /> instance.
            It is expected to be used with anonymous delegates / lambda expressions and only one
            method should be called.
            </summary>
      <example>
            IService mockSrv = mocks.CreateMock(typeof(IService)) as IService;
            Expect.Call(delegate{ mockSrv.Start(); }).Throw(new NetworkException());
            ...
            </example>
    </member>
    <member name="M:Rhino.Mocks.Expect.On(System.Object)">
      <summary>
            Get the method options for the last method call on the mockInstance.
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Interfaces.IExpectation">
      <summary>
            Interface to validate that a method call is correct.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IExpectation.IsExpected(System.Object[])">
      <summary>
            Validate the arguments for the method.
            This method can be called numerous times, so be careful about side effects
            </summary>
      <param name="args">The arguments with which the method was called</param>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IExpectation.AddActualCall">
      <summary>
            Add an actual method call to this expectation
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IExpectation.ReturnOrThrow(Castle.Core.Interceptor.IInvocation,System.Object[])">
      <summary>
            Returns the return value or throw the exception and setup any output / ref parameters
            that has been set.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Interfaces.IExpectation.ErrorMessage">
      <summary>
            Gets the error message.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Rhino.Mocks.Interfaces.IExpectation.Expected">
      <summary>
            Range of expected calls
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Interfaces.IExpectation.ActualCalls">
      <summary>
            Number of call actually made for this method
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Interfaces.IExpectation.CanAcceptCalls">
      <summary>
            If this expectation is still waiting for calls.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Interfaces.IExpectation.ReturnValue">
      <summary>
            The return value for a method matching this expectation
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Interfaces.IExpectation.ExceptionToThrow">
      <summary>
            Gets or sets the exception to throw on a method matching this expectation.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Interfaces.IExpectation.ActionsSatisfied">
      <summary>
            Gets a value indicating whether this instance's action is staisfied.
            A staisfied instance means that there are no more requirements from
            this method. A method with non void return value must register either
            a return value or an exception to throw.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Interfaces.IExpectation.Method">
      <summary>
            Gets the method this expectation is for.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Interfaces.IExpectation.RepeatableOption">
      <summary>
            Gets or sets what special condtions there are for this method
            repeating.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Interfaces.IExpectation.ExpectationSatisfied">
      <summary>
            Gets a value indicating whether this expectation was satisfied
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Interfaces.IExpectation.HasReturnValue">
      <summary>
            Specify whatever this expectation has a return value set
            You can't check ReturnValue for this because a valid return value include null.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Interfaces.IExpectation.ActionToExecute">
      <summary>
            An action to execute when the method is matched.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Interfaces.IExpectation.OutRefParams">
      <summary>
            Set the out / ref parameters for the method call.
            The indexing is zero based and ignores any non out/ref parameter.
            It is possible not to pass all the parameters. This method can be called only once.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Interfaces.IExpectation.Message">
      <summary>
            Documentation Message
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Interfaces.IExpectation.Originalinvocation">
      <summary>
            Gets the invocation for this expectation
            </summary>
      <value>The invocation.</value>
    </member>
    <member name="T:Rhino.Mocks.Expectations.AbstractExpectation">
      <summary>
            Abstract class that holds common information for 
            expectations.
            </summary>
    </member>
    <member name="F:Rhino.Mocks.Expectations.AbstractExpectation.actualCalls">
      <summary>
            Number of actuall calls made that passed this expectation
            </summary>
    </member>
    <member name="F:Rhino.Mocks.Expectations.AbstractExpectation.expected">
      <summary>
            Range of expected calls that should pass this expectation.
            </summary>
    </member>
    <member name="F:Rhino.Mocks.Expectations.AbstractExpectation.returnValue">
      <summary>
            The return value for a method matching this expectation
            </summary>
    </member>
    <member name="F:Rhino.Mocks.Expectations.AbstractExpectation.exceptionToThrow">
      <summary>
            The exception to throw on a method matching this expectation.
            </summary>
    </member>
    <member name="F:Rhino.Mocks.Expectations.AbstractExpectation.method">
      <summary>
            The method this expectation is for.
            </summary>
    </member>
    <member name="F:Rhino.Mocks.Expectations.AbstractExpectation.returnValueSet">
      <summary>
            The return value for this method was set
            </summary>
    </member>
    <member name="F:Rhino.Mocks.Expectations.AbstractExpectation.repeatableOption">
      <summary>
            Whether this method will repeat
            unlimited number of times.
            </summary>
    </member>
    <member name="F:Rhino.Mocks.Expectations.AbstractExpectation.actionToExecute">
      <summary>
            A delegate that will be run when the 
            expectation is matched.
            </summary>
    </member>
    <member name="F:Rhino.Mocks.Expectations.AbstractExpectation.matchingArgs">
      <summary>
            The arguments that matched this expectation.
            </summary>
    </member>
    <member name="F:Rhino.Mocks.Expectations.AbstractExpectation.message">
      <summary>
            Documentation message
            </summary>
    </member>
    <member name="F:Rhino.Mocks.Expectations.AbstractExpectation.originalInvocation">
      <summary>
            The method originalInvocation
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Expectations.AbstractExpectation.GetHashCode">
      <summary>
            Get the hash code
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Expectations.AbstractExpectation.AddActualCall">
      <summary>
            Add an actual method call to this expectation
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Expectations.AbstractExpectation.ReturnOrThrow(Castle.Core.Interceptor.IInvocation,System.Object[])">
      <summary>
            Returns the return value or throw the exception and setup output / ref parameters
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Expectations.AbstractExpectation.IsExpected(System.Object[])">
      <summary>
            Validate the arguments for the method on the child methods
            </summary>
      <param name="args">The arguments with which the method was called</param>
    </member>
    <member name="M:Rhino.Mocks.Expectations.AbstractExpectation.#ctor(Castle.Core.Interceptor.IInvocation)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Expectations.AbstractExpectation" /> instance.
            </summary>
      <param name="invocation">The originalInvocation for this method, required because it contains the generic type infromation</param>
    </member>
    <member name="M:Rhino.Mocks.Expectations.AbstractExpectation.#ctor(Rhino.Mocks.Interfaces.IExpectation)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Expectations.AbstractExpectation" /> instance.
            </summary>
      <param name="expectation">Expectation.</param>
    </member>
    <member name="M:Rhino.Mocks.Expectations.AbstractExpectation.DoIsExpected(System.Object[])">
      <summary>
            Validate the arguments for the method on the child methods
            </summary>
      <param name="args">The arguments with which the method was called</param>
    </member>
    <member name="M:Rhino.Mocks.Expectations.AbstractExpectation.Equals(System.Object)">
      <summary>
            Determines if this object equal to obj
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Expectations.AbstractExpectation.CreateErrorMessage(System.String)">
      <summary>
            The error message for these arguments
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Expectations.AbstractExpectation.AssertDelegateArgumentsMatchMethod(System.Delegate)">
      <summary>
            Asserts that the delegate has the same parameters as the expectation's method call
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Expectations.AbstractExpectation.OutRefParams">
      <summary>
            Setter for the outpur / ref parameters for this expecataion.
            Can only be set once.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Expectations.AbstractExpectation.HasReturnValue">
      <summary>
            Specify whatever this expectation has a return value set
            You can't check ReturnValue for this because a valid return value include null.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Expectations.AbstractExpectation.Method">
      <summary>
            Gets the method this expectation is for.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Expectations.AbstractExpectation.Originalinvocation">
      <summary>
            Gets the originalInvocation for this expectation
            </summary>
      <value>The originalInvocation.</value>
    </member>
    <member name="P:Rhino.Mocks.Expectations.AbstractExpectation.RepeatableOption">
      <summary>
            Gets or sets what special condtions there are for this method
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Expectations.AbstractExpectation.Expected">
      <summary>
            Range of expected calls
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Expectations.AbstractExpectation.ActualCalls">
      <summary>
            Number of call actually made for this method
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Expectations.AbstractExpectation.CanAcceptCalls">
      <summary>
            If this expectation is still waiting for calls.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Expectations.AbstractExpectation.ExpectationSatisfied">
      <summary>
            Gets a value indicating whether this expectation was satisfied
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Expectations.AbstractExpectation.ReturnValue">
      <summary>
            The return value for a method matching this expectation
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Expectations.AbstractExpectation.ActionToExecute">
      <summary>
            An action to execute when the method is matched.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Expectations.AbstractExpectation.ExceptionToThrow">
      <summary>
            Gets or sets the exception to throw on a method matching this expectation.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Expectations.AbstractExpectation.ActionsSatisfied">
      <summary>
            Gets a value indicating whether this instance's action is staisfied.
            A staisfied instance means that there are no more requirements from
            this method. A method with non void return value must register either
            a return value or an exception to throw or an action to execute.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Expectations.AbstractExpectation.Message">
      <summary>
            Documentation message
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Expectations.AbstractExpectation.ErrorMessage">
      <summary>
            Gets the error message.
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Rhino.Mocks.Expectations.AnyArgsExpectation">
      <summary>
            Expectation that matchs any arguments for the method.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Expectations.AnyArgsExpectation.#ctor(Castle.Core.Interceptor.IInvocation)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Expectations.AnyArgsExpectation" /> instance.
            </summary>
      <param name="invocation">Invocation for this expectation</param>
    </member>
    <member name="M:Rhino.Mocks.Expectations.AnyArgsExpectation.#ctor(Rhino.Mocks.Interfaces.IExpectation)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Expectations.AnyArgsExpectation" /> instance.
            </summary>
      <param name="expectation">Expectation.</param>
    </member>
    <member name="M:Rhino.Mocks.Expectations.AnyArgsExpectation.DoIsExpected(System.Object[])">
      <summary>
            Validate the arguments for the method.
            </summary>
      <param name="args">The arguments with which the method was called</param>
    </member>
    <member name="M:Rhino.Mocks.Expectations.AnyArgsExpectation.Equals(System.Object)">
      <summary>
            Determines if the object equal to expectation
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Expectations.AnyArgsExpectation.GetHashCode">
      <summary>
            Get the hash code
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Expectations.AnyArgsExpectation.ErrorMessage">
      <summary>
            Gets the error message.
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Rhino.Mocks.Expectations.ArgsEqualExpectation">
      <summary>
            Summary description for ArgsEqualExpectation.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Expectations.ArgsEqualExpectation.#ctor(Castle.Core.Interceptor.IInvocation,System.Object[])">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Expectations.ArgsEqualExpectation" /> instance.
            </summary>
      <param name="expectedArgs">Expected args.</param>
      <param name="invocation">The invocation for this expectation</param>
    </member>
    <member name="M:Rhino.Mocks.Expectations.ArgsEqualExpectation.DoIsExpected(System.Object[])">
      <summary>
            Validate the arguments for the method.
            </summary>
      <param name="args">The arguments with which the method was called</param>
    </member>
    <member name="M:Rhino.Mocks.Expectations.ArgsEqualExpectation.Equals(System.Object)">
      <summary>
            Determines if the object equal to expectation
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Expectations.ArgsEqualExpectation.GetHashCode">
      <summary>
            Get the hash code
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Expectations.ArgsEqualExpectation.ErrorMessage">
      <summary>
            Gets the error message.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Rhino.Mocks.Expectations.ArgsEqualExpectation.ExpectedArgs">
      <summary>
            Get the expected args.
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Expectations.CallbackExpectation">
      <summary>
            Call a specified callback to verify the expectation
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Expectations.CallbackExpectation.#ctor(Rhino.Mocks.Interfaces.IExpectation,System.Delegate)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Expectations.CallbackExpectation" /> instance.
            </summary>
      <param name="expectation">Expectation.</param>
      <param name="callback">Callback.</param>
    </member>
    <member name="M:Rhino.Mocks.Expectations.CallbackExpectation.#ctor(Castle.Core.Interceptor.IInvocation,System.Delegate)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Expectations.CallbackExpectation" /> instance.
            </summary>
      <param name="invocation">Invocation for this expectation</param>
      <param name="callback">Callback.</param>
    </member>
    <member name="M:Rhino.Mocks.Expectations.CallbackExpectation.DoIsExpected(System.Object[])">
      <summary>
            Validate the arguments for the method on the child methods
            </summary>
      <param name="args">The arguments with which the method was called</param>
    </member>
    <member name="M:Rhino.Mocks.Expectations.CallbackExpectation.Equals(System.Object)">
      <summary>
            Determines if the object equal to expectation
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Expectations.CallbackExpectation.GetHashCode">
      <summary>
            Get the hash code
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Expectations.CallbackExpectation.ErrorMessage">
      <summary>
            Gets the error message.
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Rhino.Mocks.Expectations.ConstraintsExpectation">
      <summary>
            Expect the method's arguments to match the contraints
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Expectations.ConstraintsExpectation.#ctor(Castle.Core.Interceptor.IInvocation,Rhino.Mocks.Constraints.AbstractConstraint[])">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Expectations.ConstraintsExpectation" /> instance.
            </summary>
      <param name="invocation">Invocation for this expectation</param>
      <param name="constraints">Constraints.</param>
    </member>
    <member name="M:Rhino.Mocks.Expectations.ConstraintsExpectation.#ctor(Rhino.Mocks.Interfaces.IExpectation,Rhino.Mocks.Constraints.AbstractConstraint[])">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Expectations.ConstraintsExpectation" /> instance.
            </summary>
      <param name="expectation">Expectation.</param>
      <param name="constraints">Constraints.</param>
    </member>
    <member name="M:Rhino.Mocks.Expectations.ConstraintsExpectation.DoIsExpected(System.Object[])">
      <summary>
            Validate the arguments for the method.
            </summary>
      <param name="args">The arguments with which the method was called</param>
    </member>
    <member name="M:Rhino.Mocks.Expectations.ConstraintsExpectation.Equals(System.Object)">
      <summary>
            Determines if the object equal to expectation
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Expectations.ConstraintsExpectation.GetHashCode">
      <summary>
            Get the hash code
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Expectations.ConstraintsExpectation.ErrorMessage">
      <summary>
            Gets the error message.
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Rhino.Mocks.Interfaces.IExpectationLogger">
      <summary>
            Log expectations - allows to see what is going on inside Rhino Mocks
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IExpectationLogger.LogRecordedExpectation(Castle.Core.Interceptor.IInvocation,Rhino.Mocks.Interfaces.IExpectation)">
      <summary>
            Logs the expectation as is was recorded
            </summary>
      <param name="invocation">The invocation.</param>
      <param name="expectation">The expectation.</param>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IExpectationLogger.LogReplayedExpectation(Castle.Core.Interceptor.IInvocation,Rhino.Mocks.Interfaces.IExpectation)">
      <summary>
            Logs the expectation as it was recorded
            </summary>
      <param name="invocation">The invocation.</param>
      <param name="expectation">The expectation.</param>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IExpectationLogger.LogUnexpectedMethodCall(Castle.Core.Interceptor.IInvocation,System.String)">
      <summary>
            Logs the unexpected method call.
            </summary>
      <param name="invocation">The invocation.</param>
      <param name="message">The message.</param>
    </member>
    <member name="T:Rhino.Mocks.Impl.NullLogger">
      <summary>
            Doesn't log anything, just makes happy noises
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Impl.RemotingMock.IRemotingProxyOperation">
      <summary>
            Operation on a remoting proxy
            </summary>
      <remarks>
            It is not possible to directly communicate to a real proxy via transparent proxy.
            Transparent proxy impersonates a user type and only methods of that user type are callable.
            The only methods that are guaranteed to exist on any transparent proxy are methods defined
            in Object: namely ToString(), GetHashCode(), and Equals()).
            
            These three methods are the only way to tell the real proxy to do something.
            Equals() is the most suitable of all, since it accepts an arbitrary object parameter.
            The RemotingProxy code is built so that if it is compared to an IRemotingProxyOperation,
            transparentProxy.Equals(operation) will call operation.Process(realProxy).
            This way we can retrieve a real proxy from transparent proxy and perform
            arbitrary operation on it. 
            </remarks>
    </member>
    <member name="T:Rhino.Mocks.Impl.RemotingMock.RemotingMockGenerator">
      <summary>
            Generates remoting proxies and provides utility functions
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.RemotingMock.RemotingMockGenerator.CreateRemotingMock(System.Type,Castle.Core.Interceptor.IInterceptor,Rhino.Mocks.Interfaces.IMockedObject)">
      <summary>
             Create the proxy using remoting
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.RemotingMock.RemotingMockGenerator.IsRemotingProxy(System.Object)">
      <summary>
            Check whether an object is a transparent proxy with a RemotingProxy behind it
            </summary>
      <param name="obj">Object to check</param>
      <returns>true if the object is a transparent proxy with a RemotingProxy instance behind it, false otherwise</returns>
      <remarks>We use Equals() method to communicate with the real proxy behind the object.
            See IRemotingProxyOperation for more details</remarks>
    </member>
    <member name="M:Rhino.Mocks.Impl.RemotingMock.RemotingMockGenerator.GetMockedObjectFromProxy(System.Object)">
      <summary>
            Retrieve a mocked object from a transparent proxy
            </summary>
      <param name="proxy">Transparent proxy with a RemotingProxy instance behind it</param>
      <returns>Mocked object associated with the proxy</returns>
      <remarks>We use Equals() method to communicate with the real proxy behind the object.
            See IRemotingProxyOperation for more details</remarks>
    </member>
    <member name="T:Rhino.Mocks.Impl.RemotingMock.RemotingInvocation">
      <summary>
            Implementation of IInvocation based on remoting proxy
            </summary>
      <remarks>Some methods are marked NotSupported since they either don't make sense
            for remoting proxies, or they are never called by Rhino Mocks</remarks>
    </member>
    <member name="T:Rhino.Mocks.Impl.TextWriterExpectationLogger">
      <summary>
            Rudimetry implementation that simply logs methods calls as text.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.TextWriterExpectationLogger.#ctor(System.IO.TextWriter)">
      <summary>
            Initializes a new instance of the <see cref="T:Rhino.Mocks.Impl.TextWriterExpectationLogger" /> class.
            </summary>
      <param name="writer">The writer.</param>
    </member>
    <member name="M:Rhino.Mocks.Impl.TextWriterExpectationLogger.LogRecordedExpectation(Castle.Core.Interceptor.IInvocation,Rhino.Mocks.Interfaces.IExpectation)">
      <summary>
            Logs the expectation as is was recorded
            </summary>
      <param name="invocation">The invocation.</param>
      <param name="expectation">The expectation.</param>
    </member>
    <member name="M:Rhino.Mocks.Impl.TextWriterExpectationLogger.LogReplayedExpectation(Castle.Core.Interceptor.IInvocation,Rhino.Mocks.Interfaces.IExpectation)">
      <summary>
            Logs the expectation as it was recorded
            </summary>
      <param name="invocation">The invocation.</param>
      <param name="expectation">The expectation.</param>
    </member>
    <member name="M:Rhino.Mocks.Impl.TextWriterExpectationLogger.LogUnexpectedMethodCall(Castle.Core.Interceptor.IInvocation,System.String)">
      <summary>
            Logs the unexpected method call.
            </summary>
      <param name="invocation">The invocation.</param>
      <param name="message">The message.</param>
    </member>
    <member name="T:Rhino.Mocks.Interfaces.IMockState">
      <summary>
            Different actions on this mock
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMockState.MethodCall(Castle.Core.Interceptor.IInvocation,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Add a method call for this state' mock.
            </summary>
      <param name="invocation">The invocation for this method</param>
      <param name="method">The method that was called</param>
      <param name="args">The arguments this method was called with</param>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMockState.Verify">
      <summary>
            Verify that this mock expectations have passed.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMockState.Replay">
      <summary>
            Verify that we can move to replay state and move 
            to the reply state.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMockState.BackToRecord">
      <summary>
            Gets a mock state that match the original mock state of the object.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMockState.GetLastMethodOptions``1">
      <summary>
            Get the options for the last method call
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMockState.SetExceptionToThrowOnVerify(System.Exception)">
      <summary>
            Set the exception to throw when Verify is called.
            This is used to report exception that may have happened but where caught in the code.
            This way, they are reported anyway when Verify() is called.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Interfaces.IMockState.VerifyState">
      <summary>
            Gets the matching verify state for this state
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Interfaces.IMockState.LastMethodOptions">
      <summary>
            Get the options for the last method call
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Impl.RecordMockState">
      <summary>
            Records all the expectations for a mock
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.RecordMockState.GetLastMethodOptions``1">
      <summary>
            Get the options for the last method call
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.RecordMockState.SetExceptionToThrowOnVerify(System.Exception)">
      <summary>
            Set the exception to throw when Verify is called.
            This is used to report exception that may have happened but where caught in the code.
            This way, they are reported anyway when Verify() is called.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.RecordMockState.#ctor(Rhino.Mocks.Interfaces.IMockedObject,Rhino.Mocks.MockRepository)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Impl.RecordMockState" /> instance.
            </summary>
      <param name="repository">Repository.</param>
      <param name="mockedObject">The proxy that generates the method calls</param>
    </member>
    <member name="M:Rhino.Mocks.Impl.RecordMockState.MethodCall(Castle.Core.Interceptor.IInvocation,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Add a method call for this state' mock.
            </summary>
      <param name="invocation">The invocation for this method</param>
      <param name="method">The method that was called</param>
      <param name="args">The arguments this method was called with</param>
    </member>
    <member name="M:Rhino.Mocks.Impl.RecordMockState.Replay">
      <summary>
            Verify that we can move to replay state and move 
            to the reply state.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.RecordMockState.DoReplay">
      <summary>
            Verify that we can move to replay state and move 
            to the reply state.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.RecordMockState.Verify">
      <summary>
            Verify that this mock expectations have passed.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.RecordMockState.BackToRecord">
      <summary>
            Gets a mock state that match the original mock state of the object.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.RecordMockState.AssertPreviousMethodIsClose">
      <summary>
            Asserts the previous method is closed (had an expectation set on it so we can replay it correctly)
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Impl.RecordMockState.LastExpectation">
      <summary>
            Gets the last expectation.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Impl.RecordMockState.MethodCallsCount">
      <summary>
            Gets the total method calls count.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Impl.RecordMockState.LastMethodOptions">
      <summary>
            Get the options for the last method call
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Impl.RecordMockState.VerifyState">
      <summary>
            Gets the matching verify state for this state
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Impl.StubRecordMockState">
      <summary>
            Behave like a stub, all properties and events acts normally, methods calls
            return default values by default (but can use expectations to set them up), etc.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.StubRecordMockState.#ctor(Rhino.Mocks.Interfaces.IMockedObject,Rhino.Mocks.MockRepository)">
      <summary>
            Initializes a new instance of the <see cref="T:Rhino.Mocks.Impl.StubRecordMockState" /> class.
            </summary>
      <param name="mockedObject">The proxy that generates the method calls</param>
      <param name="repository">Repository.</param>
    </member>
    <member name="M:Rhino.Mocks.Impl.StubRecordMockState.AssertPreviousMethodIsClose">
      <summary>
            We don't care much about expectations here, so we will remove the exepctation if
            it is not closed.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.StubRecordMockState.Replay">
      <summary>
            Verify that we can move to replay state and move
            to the reply state.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Rhino.Mocks.Impl.ReplayMockState">
      <summary>
            Validate all expectations on a mock
            </summary>
    </member>
    <member name="F:Rhino.Mocks.Impl.ReplayMockState.repository">
      <summary>
            The repository for this state
            </summary>
    </member>
    <member name="F:Rhino.Mocks.Impl.ReplayMockState.proxy">
      <summary>
            The proxy object for this state
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.ReplayMockState.GetLastMethodOptions``1">
      <summary>
            Get the options for the last method call
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.ReplayMockState.#ctor(Rhino.Mocks.Impl.RecordMockState)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Impl.ReplayMockState" /> instance.
            </summary>
      <param name="previousState">The previous state for this method</param>
    </member>
    <member name="M:Rhino.Mocks.Impl.ReplayMockState.MethodCall(Castle.Core.Interceptor.IInvocation,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Add a method call for this state' mock.
            </summary>
      <param name="invocation">The invocation for this method</param>
      <param name="method">The method that was called</param>
      <param name="args">The arguments this method was called with</param>
    </member>
    <member name="M:Rhino.Mocks.Impl.ReplayMockState.DoMethodCall(Castle.Core.Interceptor.IInvocation,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Add a method call for this state' mock.
            This allows derived method to cleanly get a the setupresult behavior while adding
            their own.
            </summary>
      <param name="invocation">The invocation for this method</param>
      <param name="method">The method that was called</param>
      <param name="args">The arguments this method was called with</param>
    </member>
    <member name="M:Rhino.Mocks.Impl.ReplayMockState.SetExceptionToThrowOnVerify(System.Exception)">
      <summary>
            Set the exception to throw when Verify is called.
            This is used to report exception that may have happened but where caught in the code.
            This way, they are reported anyway when Verify() is called.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.ReplayMockState.Verify">
      <summary>
            Verify that this mock expectations have passed.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.ReplayMockState.Replay">
      <summary>
            Verify that we can move to replay state and move 
            to the reply state.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.ReplayMockState.BackToRecord">
      <summary>
            Gets a mock state that match the original mock state of the object.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Impl.ReplayMockState.LastMethodOptions">
      <summary>
            Get the options for the last method call
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Impl.ReplayMockState.VerifyState">
      <summary>
            Gets the matching verify state for this state
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Impl.StubReplayMockState">
      <summary>
            Validate expectations on recorded methods, but in general completely ignoring them.
            Similar to <seealso cref="T:Rhino.Mocks.Impl.ReplayDynamicMockState" /> except that it would return a 
            <seealso cref="T:Rhino.Mocks.Impl.StubRecordMockState" /> when BackToRecord is called.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.StubReplayMockState.#ctor(Rhino.Mocks.Impl.RecordMockState)">
      <summary>
            Initializes a new instance of the <see cref="T:Rhino.Mocks.Impl.StubReplayMockState" /> class.
            </summary>
      <param name="previousState">The previous state for this method</param>
    </member>
    <member name="M:Rhino.Mocks.Impl.StubReplayMockState.DoMethodCall(Castle.Core.Interceptor.IInvocation,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Add a method call for this state' mock.
            </summary>
      <param name="invocation">The invocation for this method</param>
      <param name="method">The method that was called</param>
      <param name="args">The arguments this method was called with</param>
    </member>
    <member name="M:Rhino.Mocks.Impl.StubReplayMockState.BackToRecord">
      <summary>
            Gets a mock state that match the original mock state of the object.
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Impl.TraceWriterExpectationLogger">
      <summary>
      </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.TraceWriterExpectationLogger.#ctor">
      <summary>
      </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.TraceWriterExpectationLogger.#ctor(System.Boolean,System.Boolean,System.Boolean)">
      <summary>
      </summary>
      <param name="logRecorded">
      </param>
      <param name="logReplayed">
      </param>
      <param name="logUnexpected">
      </param>
    </member>
    <member name="M:Rhino.Mocks.Impl.TraceWriterExpectationLogger.LogRecordedExpectation(Castle.Core.Interceptor.IInvocation,Rhino.Mocks.Interfaces.IExpectation)">
      <summary>
      </summary>
      <param name="invocation">
      </param>
      <param name="expectation">
      </param>
    </member>
    <member name="M:Rhino.Mocks.Impl.TraceWriterExpectationLogger.LogReplayedExpectation(Castle.Core.Interceptor.IInvocation,Rhino.Mocks.Interfaces.IExpectation)">
      <summary>
      </summary>
      <param name="invocation">
      </param>
      <param name="expectation">
      </param>
    </member>
    <member name="M:Rhino.Mocks.Impl.TraceWriterExpectationLogger.LogUnexpectedMethodCall(Castle.Core.Interceptor.IInvocation,System.String)">
      <summary>
      </summary>
      <param name="invocation">
      </param>
      <param name="message">
      </param>
    </member>
    <member name="T:Rhino.Mocks.Interfaces.IPartialMockMarker">
      <summary>
            Marker interface used to indicate that this is a partial mock.
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Interfaces.OriginalCallOptions">
      <summary>
            Options for CallOriginalMethod
            </summary>
    </member>
    <member name="F:Rhino.Mocks.Interfaces.OriginalCallOptions.NoExpectation">
      <summary>
            No expectation is created, the method will be called directly
            </summary>
    </member>
    <member name="F:Rhino.Mocks.Interfaces.OriginalCallOptions.CreateExpectation">
      <summary>
            Normal expectation is created, but when the method is later called, it will also call the original method
            </summary>
    </member>
    <member name="T:Rhino.Mocks.MockRepository">
      <summary>
             Adds optional new usage:
               using(mockRepository.Record()) {
                  Expect.Call(mock.Method()).Return(retVal);
               }
               using(mockRepository.Playback()) {
                  // Execute code
               }
             N.B. mockRepository.ReplayAll() and mockRepository.VerifyAll()
                  calls are taken care of by Record/Playback
            </summary>
      <summary>
            Creates proxied instances of types.
            </summary>
    </member>
    <member name="T:Rhino.Mocks.MockRepository.CreateMockState">
      <summary>
             Delegate: CreateMockState
             This is used internally to cleanly handle the creation of different 
             RecordMockStates.
            </summary>
    </member>
    <member name="F:Rhino.Mocks.MockRepository.lastRepository">
      <summary>
            This is used to record the last repository that has a method called on it.
            </summary>
    </member>
    <member name="F:Rhino.Mocks.MockRepository.lastMockedObject">
      <summary>
            this is used to get to the last proxy on this repository.
            </summary>
    </member>
    <member name="F:Rhino.Mocks.MockRepository.delegateProxies">
      <summary>
            For mock delegates, maps the proxy instance from intercepted invocations
            back to the delegate that was originally returned to client code, if any.
            </summary>
    </member>
    <member name="F:Rhino.Mocks.MockRepository.proxies">
      <summary>
            All the proxies in the mock repositories
            </summary>
    </member>
    <member name="F:Rhino.Mocks.MockRepository.repeatableMethods">
      <summary>
            This is here because we can't put it in any of the recorders, since repeatable methods
            have no orderring, and if we try to handle them using the usual manner, we would get into
            wierd situations where repeatable method that was defined in an orderring block doesn't
            exists until we enter this block.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.Record">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.Playback">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.#ctor">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.MockRepository" /> instance.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.Ordered">
      <summary>
            Move the repository to ordered mode
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.Unordered">
      <summary>
            Move the repository to un-ordered mode
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.CreateMock(System.Type,System.Object[])">
      <summary>
            Creates a mock for the specified type.
            </summary>
      <param name="type">Type.</param>
      <param name="argumentsForConstructor">Arguments for the class' constructor, if mocking a concrete class</param>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.CreateMultiMock(System.Type,System.Type[])">
      <summary>
            Creates a mock from several types, with strict semantics.
            Only <paramref name="mainType" /> may be a class.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.CreateMultiMock(System.Type,System.Type[],System.Object[])">
      <summary>
            Creates a mock from several types, with strict semantics.
            Only <paramref name="mainType" /> may be a class.
            </summary>
      <param name="mainType">The main type to mock.</param>
      <param name="extraTypes">Extra interface types to mock.</param>
      <param name="argumentsForConstructor">Arguments for the class' constructor, if mocking a concrete class.</param>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.DynamicMultiMock(System.Type,System.Type[])">
      <summary>
            Creates a mock from several types, with dynamic semantics.
            Only <paramref name="mainType" /> may be a class.
            </summary>
      <param name="mainType">The main type to mock.</param>
      <param name="extraTypes">Extra interface types to mock.</param>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.DynamicMultiMock(System.Type,System.Type[],System.Object[])">
      <summary>
            Creates a mock from several types, with dynamic semantics.
            Only <paramref name="mainType" /> may be a class.
            </summary>
      <param name="mainType">The main type to mock.</param>
      <param name="extraTypes">Extra interface types to mock.</param>
      <param name="argumentsForConstructor">Arguments for the class' constructor, if mocking a concrete class.</param>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.DynamicMock(System.Type,System.Object[])">
      <summary>
            Creates a dynamic mock for the specified type.
            </summary>
      <param name="type">Type.</param>
      <param name="argumentsForConstructor">Arguments for the class' constructor, if mocking a concrete class</param>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.PartialMock(System.Type,System.Object[])">
      <summary>
            Creates a mock object that defaults to calling the class methods.
            </summary>
      <param name="type">Type.</param>
      <param name="argumentsForConstructor">Arguments for the class' constructor.</param>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.PartialMultiMock(System.Type,System.Type[])">
      <summary>
            Creates a mock object that defaults to calling the class methods.
            </summary>
      <param name="type">Type.</param>
      <param name="extraTypes">Extra interface types to mock.</param>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.PartialMultiMock(System.Type,System.Type[],System.Object[])">
      <summary>
            Creates a mock object that defaults to calling the class methods.
            </summary>
      <param name="type">Type.</param>
      <param name="extraTypes">Extra interface types to mock.</param>
      <param name="argumentsForConstructor">Arguments for the class' constructor.</param>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.RemotingMock(System.Type,Rhino.Mocks.MockRepository.CreateMockState)">
      <summary>
            Creates a mock object using remoting proxies
            </summary>
      <param name="type">Type to mock - must be MarshalByRefObject</param>
      <returns>Mock object</returns>
      <remarks>Proxy mock can mock non-virtual methods, but not static methods</remarks>
      <param name="factory">Creates the mock state for this proxy</param>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.Replay(System.Object)">
      <summary>
            Cause the mock state to change to replay, any further call is compared to the 
            ones that were called in the record state.
            </summary>
      <param name="obj">the object to move to replay state</param>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.BackToRecord(System.Object)">
      <summary>
            Move the mocked object back to record state.
            Will delete all current expectations!
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.BackToRecord(System.Object,Rhino.Mocks.BackToRecordOptions)">
      <summary>
            Move the mocked object back to record state.
            Will delete all current expectations, but allows more granularity about how
            it would behave with regard to the object state.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.Verify(System.Object)">
      <summary>
            Verify that all the expectations for this object were fulfilled.
            </summary>
      <param name="obj">the object to verify the expectations for</param>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.LastMethodCall``1(System.Object)">
      <summary>
            Get the method options for the last call on
            mockedInstance.
            </summary>
      <param name="mockedInstance">The mock object</param>
      <returns>Method options for the last call</returns>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.GetMockObjectFromInvocationProxy(System.Object)">
      <summary>
            Maps an invocation proxy back to the mock object instance that was originally
            returned to client code which might have been a delegate to this proxy.
            </summary>
      <param name="invocationProxy">The mock object proxy from the intercepted invocation</param>
      <returns>The mock object</returns>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.CreateMockObject(System.Type,Rhino.Mocks.MockRepository.CreateMockState,System.Type[],System.Object[])">
      <summary>
            This is provided to allow advance extention functionality, where Rhino Mocks standard
            functionality is not enough.
            </summary>
      <param name="type">The type to mock</param>
      <param name="factory">Delegate that create the first state of the mocked object (usualy the record state).</param>
      <param name="extras">Additional types to be implemented, this can be only interfaces </param>
      <param name="argumentsForConstructor">optional arguments for the constructor</param>
      <returns>
      </returns>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.GetMockedObject(System.Object)">
      <summary>
             Method: GetMockedObject
             Get an IProxy from a mocked object instance, or throws if the 
             object is not a mock object.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.GetMockedObjectOrNull(System.Object)">
      <summary>
            Method: GetMockedObjectOrNull
            Get an IProxy from a mocked object instance, or null if the
            object is not a mock object.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.PopRecorder">
      <summary>
            Pops the recorder.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.PushRecorder(Rhino.Mocks.Interfaces.IMethodRecorder)">
      <summary>
            Pushes the recorder.
            </summary>
      <param name="newRecorder">New recorder.</param>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.BackToRecordAll">
      <summary>
            All the mock objects in this repository will be moved
            to record state.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.BackToRecordAll(Rhino.Mocks.BackToRecordOptions)">
      <summary>
            All the mock objects in this repository will be moved
            to record state.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.ReplayAll">
      <summary>
            Replay all the mocks from this repository
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.VerifyAll">
      <summary>
            Verify all the mocks from this repository
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.SetExceptionToBeThrownOnVerify(System.Object,Rhino.Mocks.Exceptions.ExpectationViolationException)">
      <summary>
            Set the exception to be thrown when verified is called.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.CreateMock``1(System.Object[])">
      <summary>
            Creates a mock for the spesified type.
            </summary>
      <param name="argumentsForConstructor">Arguments for the class' constructor, if mocking a concrete class</param>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.DynamicMock``1(System.Object[])">
      <summary>
            Creates a dynamic mock for the specified type.
            </summary>
      <param name="argumentsForConstructor">Arguments for the class' constructor, if mocking a concrete class</param>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.CreateMultiMock``1(System.Type[])">
      <summary>
            Creates a mock object from several types.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.DynamicMultiMock``1(System.Type[])">
      <summary>
            Create a mock object from several types with dynamic semantics.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.PartialMultiMock``1(System.Type[])">
      <summary>
            Create a mock object from several types with partial semantics.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.CreateMultiMock``1(System.Type[],System.Object[])">
      <summary>
            Create a mock object from several types with strict semantics.
            </summary>
      <param name="extraTypes">Extra interface types to mock.</param>
      <param name="argumentsForConstructor">Arguments for the class' constructor, if mocking a concrete class</param>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.DynamicMultiMock``1(System.Type[],System.Object[])">
      <summary>
            Create a mock object from several types with dynamic semantics.
            </summary>
      <param name="extraTypes">Extra interface types to mock.</param>
      <param name="argumentsForConstructor">Arguments for the class' constructor, if mocking a concrete class</param>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.PartialMultiMock``1(System.Type[],System.Object[])">
      <summary>
            Create a mock object from several types with partial semantics.
            </summary>
      <param name="extraTypes">Extra interface types to mock.</param>
      <param name="argumentsForConstructor">Arguments for the class' constructor, if mocking a concrete class</param>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.PartialMock``1(System.Object[])">
      <summary>
            Create a mock object with from a class that defaults to calling the class methods
            </summary>
      <param name="argumentsForConstructor">Arguments for the class' constructor, if mocking a concrete class</param>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.Stub``1(System.Object[])">
      <summary>
            Create a stub object, one that has properties and events ready for use, and 
            can have methods called on it. It requires an explicit step in order to create 
            an expectation for a stub.
            </summary>
      <param name="argumentsForConstructor">The arguments for constructor.</param>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.Stub(System.Type,System.Object[])">
      <summary>
            Create a stub object, one that has properties and events ready for use, and
            can have methods called on it. It requires an explicit step in order to create
            an expectation for a stub.
            </summary>
      <param name="type">The type.</param>
      <param name="argumentsForConstructor">The arguments for constructor.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.GenerateStub``1(System.Object[])">
      <summary>
            Generates a stub without mock repository
            </summary>
      <param name="argumentsForConstructor">The arguments for constructor.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Rhino.Mocks.MockRepository.GenerateStub(System.Type,System.Object[])">
      <summary>
            Generates the stub without mock repository
            </summary>
      <param name="type">The type.</param>
      <param name="argumentsForConstructor">The arguments for constructor.</param>
    </member>
    <member name="P:Rhino.Mocks.MockRepository.Recorder">
      <summary>
            Gets the recorder.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Rhino.Mocks.MockRepository.Replayer">
      <summary>
            Gets the replayer for this repository.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Rhino.Mocks.MockRepository.LastMockedObject">
      <summary>
            Gets the last proxy which had a method call.
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Utilities.GenericsUtil">
      <summary>
            Utility class for dealing with messing generics scenarios.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Utilities.GenericsUtil.HasOpenGenericParam(System.Type)">
      <summary>
            There are issues with trying to get this to work correctly with open generic types, since this is an edge case, 
            I am letting the runtime handle it.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Utilities.GenericsUtil.GetRealType(System.Type,Castle.Core.Interceptor.IInvocation)">
      <summary>
            Gets the real type, including de-constructing and constructing the type of generic
            methods parameters.
            </summary>
      <param name="type">The type.</param>
      <param name="invocation">The invocation.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Rhino.Mocks.Utilities.GenericsUtil.ReconstructGenericType(System.Type,System.Collections.Generic.Dictionary{System.String,System.Type})">
      <summary>
            Because we need to support complex types here (simple generics were handled above) we
            need to be aware of the following scenarios:
            List[T] and List[Foo[T]]
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Generated.ExpectationsList">
      <summary>
            ExpectationsList
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Generated.ProxyMethodExpectationsDictionary">
      <summary>
            Dictionary
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Generated.ProxyStateDictionary">
      <summary>
            Dictionary class
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Generated.ProxyStateDictionary.#ctor">
      <summary>
            Create a new instance of <c>ProxyStateDictionary</c></summary>
    </member>
    <member name="T:Rhino.Mocks.Interfaces.ICreateMethodExpectation">
      <summary>
            Interface to allows to call a method and immediatly get it's options.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.ICreateMethodExpectation.Call``1(``0)">
      <summary>
            Get the method options for the call
            </summary>
      <param name="ignored">The method call should go here, the return value is ignored</param>
    </member>
    <member name="T:Rhino.Mocks.Impl.CreateMethodExpectation">
      <summary>
            Allows to call a method and immediatly get it's options.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.CreateMethodExpectation.#ctor(Rhino.Mocks.Interfaces.IMockedObject,System.Object)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Impl.CreateMethodExpectation" /> instance.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.CreateMethodExpectation.Call``1(``0)">
      <summary>
            Get the method options for the call
            </summary>
      <param name="ignored">The method call should go here, the return value is ignored</param>
    </member>
    <member name="T:Rhino.Mocks.Impl.CreateMethodExpectationForSetupResult">
      <summary>
            Allows to call a method and immediatly get it's options.
            Set the expected number for the call to Any() 
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.CreateMethodExpectationForSetupResult.#ctor(Rhino.Mocks.Interfaces.IMockedObject,System.Object)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Impl.CreateMethodExpectationForSetupResult" /> instance.
            </summary>
      <param name="mockedObject">Proxy.</param>
      <param name="mockedInstance">Mocked instance.</param>
    </member>
    <member name="M:Rhino.Mocks.Impl.CreateMethodExpectationForSetupResult.Call``1(``0)">
      <summary>
            Get the method options for the call
            </summary>
      <param name="ignored">The method call should go here, the return value is ignored</param>
    </member>
    <member name="T:Rhino.Mocks.Impl.DelegateTargetInterfaceCreator">
      <summary>
            This class is reponsible for taking a delegate and creating a wrapper
            interface around it, so it can be mocked.
            </summary>
    </member>
    <member name="F:Rhino.Mocks.Impl.DelegateTargetInterfaceCreator.moduleScope">
      <summary>
            The scope for all the delegate interfaces create by this mock repositroy.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.DelegateTargetInterfaceCreator.GetDelegateTargetInterface(System.Type)">
      <summary>
            Gets a type with an "Invoke" method suitable for use as a target of the
            specified delegate type.
            </summary>
      <param name="delegateType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Rhino.Mocks.Interfaces.IEventRaiser">
      <summary>
            Raise events for all subscribers for an event
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IEventRaiser.Raise(System.Object[])">
      <summary>
            Raise the event
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IEventRaiser.Raise(System.Object,System.EventArgs)">
      <summary>
            The most common form for the event handler signature
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Impl.EventRaiser">
      <summary>
            Raise events for all subscribers for an event
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.EventRaiser.Create(System.Object,System.String)">
      <summary>
             Create an event raise for the specified event on this instance.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.EventRaiser.#ctor(Rhino.Mocks.Interfaces.IMockedObject,System.String)">
      <summary>
            Creates a new instance of <c>EventRaiser</c></summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.EventRaiser.Raise(System.Object[])">
      <summary>
            Raise the event
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.EventRaiser.Raise(System.Object,System.EventArgs)">
      <summary>
            The most common signature for events
            Here to allow intellisense to make better guesses about how 
            it should suggest parameters.
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Interfaces.IMethodOptions`1">
      <summary>
            Allows to define what would happen when a method 
            is called.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodOptions`1.Return(`0)">
      <summary>
            Set the return value for the method.
            </summary>
      <param name="objToReturn">The object the method will return</param>
      <returns>IRepeat that defines how many times the method will return this value</returns>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodOptions`1.Throw(System.Exception)">
      <summary>
            Throws the specified exception when the method is called.
            </summary>
      <param name="exception">Exception to throw</param>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodOptions`1.IgnoreArguments">
      <summary>
            Ignores the arguments for this method. Any argument will be matched
            againt this method.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodOptions`1.Constraints(Rhino.Mocks.Constraints.AbstractConstraint[])">
      <summary>
            Add constraints for the method's arguments.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodOptions`1.Callback(System.Delegate)">
      <summary>
            Set a callback method for the last call
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodOptions`1.Do(System.Delegate)">
      <summary>
            Set a delegate to be called when the expectation is matched.
            The delegate return value will be returned from the expectation.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodOptions`1.CallOriginalMethod">
      <summary>
            Call the original method on the class, bypassing the mocking layers.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodOptions`1.CallOriginalMethod(Rhino.Mocks.Interfaces.OriginalCallOptions)">
      <summary>
            Call the original method on the class, optionally bypassing the mocking layers.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodOptions`1.PropertyBehavior">
      <summary>
            Use the property as a simple property, getting/setting the values without
            causing mock expectations.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodOptions`1.GetEventRaiser">
      <summary>
            Get an event raiser for the last subscribed event.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodOptions`1.OutRef(System.Object[])">
      <summary>
            Set the parameter values for out and ref parameters.
            This is done using zero based indexing, and _ignoring_ any non out/ref parameter.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodOptions`1.Message(System.String)">
      <summary>
            Documentation message for the expectation
            </summary>
      <param name="documentationMessage">Message</param>
    </member>
    <member name="P:Rhino.Mocks.Interfaces.IMethodOptions`1.Repeat">
      <summary>
            Better syntax to define repeats. 
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Interfaces.IRepeat`1">
      <summary>
            Allows to specify the number of time for method calls
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IRepeat`1.Twice">
      <summary>
            Repeat the method twice.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IRepeat`1.Once">
      <summary>
            Repeat the method once.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IRepeat`1.AtLeastOnce">
      <summary>
            Repeat the method at least once, then repeat as many time as it would like.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IRepeat`1.Any">
      <summary>
            Repeat the method any number of times.
            This has special affects in that this method would now ignore orderring.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IRepeat`1.Times(System.Int32,System.Int32)">
      <summary>
            Set the range to repeat an action.
            </summary>
      <param name="min">Min.</param>
      <param name="max">Max.</param>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IRepeat`1.Times(System.Int32)">
      <summary>
            Set the amount of times to repeat an action.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IRepeat`1.Never">
      <summary>
            This method must not appear in the replay state.
            This has special affects in that this method would now ignore orderring.
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Impl.MethodOptions`1">
      <summary>
            Allows to define what would happen when a method 
            is called.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.MethodOptions`1.#ctor(Rhino.Mocks.MockRepository,Rhino.Mocks.Impl.RecordMockState,Rhino.Mocks.Interfaces.IMockedObject,Rhino.Mocks.Interfaces.IExpectation)">
      <summary>
            Creates a new <see cref="T:MethodOptions`1" /> instance.
            </summary>
      <param name="repository">the repository for this expectation</param>
      <param name="record">the recorder for this proxy</param>
      <param name="proxy">the proxy for this expectation</param>
      <param name="expectation">Expectation.</param>
    </member>
    <member name="M:Rhino.Mocks.Impl.MethodOptions`1.Constraints(Rhino.Mocks.Constraints.AbstractConstraint[])">
      <summary>
            Add constraints for the method's arguments.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.MethodOptions`1.Callback(System.Delegate)">
      <summary>
            Set a callback method for the last call
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.MethodOptions`1.Do(System.Delegate)">
      <summary>
            Set a delegate to be called when the expectation is matched.
            The delegate return value will be returned from the expectation.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.MethodOptions`1.Return(`0)">
      <summary>
            Set the return value for the method.
            </summary>
      <param name="objToReturn">The object the method will return</param>
      <returns>IRepeat that defines how many times the method will return this value</returns>
    </member>
    <member name="M:Rhino.Mocks.Impl.MethodOptions`1.Throw(System.Exception)">
      <summary>
            Throws the specified exception when the method is called.
            </summary>
      <param name="exception">Exception to throw</param>
    </member>
    <member name="M:Rhino.Mocks.Impl.MethodOptions`1.IgnoreArguments">
      <summary>
            Ignores the arguments for this method. Any argument will be matched
            againt this method.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.MethodOptions`1.CallOriginalMethod">
      <summary>
            Call the original method on the class, bypassing the mocking layers.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Rhino.Mocks.Impl.MethodOptions`1.CallOriginalMethod(Rhino.Mocks.Interfaces.OriginalCallOptions)">
      <summary>
            Call the original method on the class, optionally bypassing the mocking layers
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Rhino.Mocks.Impl.MethodOptions`1.PropertyBehavior">
      <summary>
            Use the property as a simple property, getting/setting the values without
            causing mock expectations.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.MethodOptions`1.GetEventRaiser">
      <summary>
            Gets the event raiser for the last event
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.MethodOptions`1.OutRef(System.Object[])">
      <summary>
            Set the parameter values for out and ref parameters.
            This is done using zero based indexing, and _ignoring_ any non out/ref parameter.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.MethodOptions`1.Twice">
      <summary>
            Repeat the method twice.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.MethodOptions`1.Once">
      <summary>
            Repeat the method once.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.MethodOptions`1.AtLeastOnce">
      <summary>
            Repeat the method at least once, then repeat as many time as it would like.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.MethodOptions`1.Never">
      <summary>
            This method must not appear in the replay state.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.MethodOptions`1.Message(System.String)">
      <summary>
            Documentation message for the expectation
            </summary>
      <param name="documentationMessage">Message</param>
    </member>
    <member name="M:Rhino.Mocks.Impl.MethodOptions`1.Any">
      <summary>
            Repeat the method any number of times.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.MethodOptions`1.Times(System.Int32,System.Int32)">
      <summary>
            Set the range to repeat an action.
            </summary>
      <param name="min">Min.</param>
      <param name="max">Max.</param>
    </member>
    <member name="M:Rhino.Mocks.Impl.MethodOptions`1.Times(System.Int32)">
      <summary>
            Set the amount of times to repeat an action.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Impl.MethodOptions`1.Repeat">
      <summary>
            Better syntax to define repeats. 
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Impl.MockedObjectsEquality">
      <summary>
            This class will provide hash code for hashtables without needing
            to call the GetHashCode() on the object, which may very well be mocked.
            This class has no state so it is a singelton to avoid creating a lot of objects 
            that does the exact same thing. See flyweight patterns.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.MockedObjectsEquality.GetHashCode(System.Object)">
      <summary>
            Get the hash code for a proxy object without calling GetHashCode()
            on the object.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.MockedObjectsEquality.Compare(System.Object,System.Object)">
      <summary>
            Compares two instances of mocked objects
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.MockedObjectsEquality.Equals(System.Object,System.Object)">
      <summary>
            Compare two mocked objects
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Impl.MockedObjectsEquality.NextHashCode">
      <summary>
            The next hash code value for a mock object.
            This is safe for multi threading.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Impl.MockedObjectsEquality.Instance">
      <summary>
            The sole instance of <see cref="T:Rhino.Mocks.Impl.MockedObjectsEquality" /></summary>
    </member>
    <member name="T:Rhino.Mocks.Interfaces.IMockedObject">
      <summary>
            Interface to find the repository of a mocked object
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMockedObject.ShouldCallOriginal(System.Reflection.MethodInfo)">
      <summary>
            Return true if it should call the original method on the object
            instead of pass it to the message chain.
            </summary>
      <param name="method">The method to call</param>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMockedObject.RegisterMethodForCallingOriginal(System.Reflection.MethodInfo)">
      <summary>
            Register a method to be called on the object directly
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMockedObject.RegisterPropertyBehaviorFor(System.Reflection.PropertyInfo)">
      <summary>
            Register a property on the object that will behave as a simple property
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMockedObject.IsPropertyMethod(System.Reflection.MethodInfo)">
      <summary>
            Check if the method was registered as a property method.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMockedObject.HandleProperty(System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Do get/set on the property, according to need.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMockedObject.HandleEvent(System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Do add/remove on the event
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMockedObject.GetEventSubscribers(System.String)">
      <summary>
            Get the subscribers of a spesific event
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMockedObject.GetDeclaringType(System.Reflection.MethodInfo)">
      <summary>
            Gets the declaring type of the method, taking into acccount the possible generic 
            parameters that it was created with.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMockedObject.ClearState(Rhino.Mocks.BackToRecordOptions)">
      <summary>
            Clears the state of the object, remove original calls, property behavior, subscribed events, etc.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Interfaces.IMockedObject.ProxyHash">
      <summary>
            The unique hash code of this mock, which is not related
            to the value of the GetHashCode() call on the object.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Interfaces.IMockedObject.Repository">
      <summary>
            Gets the repository.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Interfaces.IMockedObject.ImplementedTypes">
      <summary>
            Gets the implemented types by this mocked object
            </summary>
      <value>The implemented.</value>
    </member>
    <member name="T:Rhino.Mocks.Impl.ProxyInstance">
      <summary>
            This is a dummy type that is used merely to give DynamicProxy the proxy instance that
            it needs to create IProxy's types.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.ProxyInstance.#ctor(Rhino.Mocks.MockRepository,System.Type[])">
      <summary>
            Create a new instance of <see cref="T:Rhino.Mocks.Impl.ProxyInstance" /></summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.ProxyInstance.ShouldCallOriginal(System.Reflection.MethodInfo)">
      <summary>
            Return true if it should call the original method on the object
            instead of pass it to the message chain.
            </summary>
      <param name="method">The method to call</param>
    </member>
    <member name="M:Rhino.Mocks.Impl.ProxyInstance.RegisterMethodForCallingOriginal(System.Reflection.MethodInfo)">
      <summary>
            Register a method to be called on the object directly
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.ProxyInstance.RegisterPropertyBehaviorFor(System.Reflection.PropertyInfo)">
      <summary>
            Register a property on the object that will behave as a simple property
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.ProxyInstance.IsPropertyMethod(System.Reflection.MethodInfo)">
      <summary>
            Check if the method was registered as a property method.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.ProxyInstance.HandleProperty(System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Do get/set on the property, according to need.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.ProxyInstance.HandleEvent(System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Do add/remove on the event
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.ProxyInstance.GetEventSubscribers(System.String)">
      <summary>
            Get the subscribers of a spesific event
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.ProxyInstance.GetDeclaringType(System.Reflection.MethodInfo)">
      <summary>
            Gets the declaring type of the method, taking into acccount the possible generic 
            parameters that it was created with.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.ProxyInstance.ClearState(Rhino.Mocks.BackToRecordOptions)">
      <summary>
            Clears the state of the object, remove original calls, property behavior, subscribed events, etc.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Impl.ProxyInstance.ProxyHash">
      <summary>
            The unique hash code of this proxy, which is not related
            to the value of the GetHashCode() call on the object.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Impl.ProxyInstance.Repository">
      <summary>
            Gets the repository.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Impl.ProxyInstance.ImplementedTypes">
      <summary>
            Gets the implemented types by this mocked object
            </summary>
      <value>The implemented.</value>
    </member>
    <member name="T:Rhino.Mocks.Impl.Range">
      <summary>
            Range for expected method calls
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.Range.#ctor(System.Int32,System.Int32)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Impl.Range" /> instance.
            </summary>
      <param name="min">Min.</param>
      <param name="max">Max.</param>
    </member>
    <member name="M:Rhino.Mocks.Impl.Range.ToString">
      <summary>
            Return the string representation of this range.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Impl.Range.Min">
      <summary>
            Gets or sets the min.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Rhino.Mocks.Impl.Range.Max">
      <summary>
            Gets or sets the max.
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Rhino.Mocks.Impl.RecordDynamicMockState">
      <summary>
            Records all the expectations for a mock and
            return a ReplayDynamicMockState when Replay()
            is called.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.RecordDynamicMockState.#ctor(Rhino.Mocks.Interfaces.IMockedObject,Rhino.Mocks.MockRepository)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Impl.RecordDynamicMockState" /> instance.
            </summary>
      <param name="repository">Repository.</param>
      <param name="mockedObject">The proxy that generates the method calls</param>
    </member>
    <member name="M:Rhino.Mocks.Impl.RecordDynamicMockState.DoReplay">
      <summary>
            Verify that we can move to replay state and move 
            to the reply state.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.RecordDynamicMockState.BackToRecord">
      <summary>
            Gets a mock state that match the original mock state of the object.
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Impl.RecordPartialMockState">
      <summary>
            Records all the expectations for a mock and
            return a ReplayPartialMockState when Replay()
            is called.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.RecordPartialMockState.#ctor(Rhino.Mocks.Interfaces.IMockedObject,Rhino.Mocks.MockRepository)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Impl.RecordDynamicMockState" /> instance.
            </summary>
      <param name="repository">Repository.</param>
      <param name="mockedObject">The proxy that generates the method calls</param>
    </member>
    <member name="M:Rhino.Mocks.Impl.RecordPartialMockState.DoReplay">
      <summary>
            Verify that we can move to replay state and move 
            to the reply state.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.RecordPartialMockState.BackToRecord">
      <summary>
            Gets a mock state that match the original mock state of the object.
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Impl.RepeatableOption">
      <summary>
            Options for special repeat option
            </summary>
    </member>
    <member name="F:Rhino.Mocks.Impl.RepeatableOption.Normal">
      <summary>
            This method can be called only as many times as the IMethodOptions.Expect allows.
            </summary>
    </member>
    <member name="F:Rhino.Mocks.Impl.RepeatableOption.Never">
      <summary>
            This method should never be called
            </summary>
    </member>
    <member name="F:Rhino.Mocks.Impl.RepeatableOption.Any">
      <summary>
            This method can be call any number of times
            </summary>
    </member>
    <member name="F:Rhino.Mocks.Impl.RepeatableOption.OriginalCall">
      <summary>
            This method will call the original method
            </summary>
    </member>
    <member name="F:Rhino.Mocks.Impl.RepeatableOption.OriginalCallBypassingMokcing">
      <summary>
            This method will call the original method, bypassing the mocking layer
            </summary>
    </member>
    <member name="F:Rhino.Mocks.Impl.RepeatableOption.PropertyBehavior">
      <summary>
            This method will simulate simple property behavior
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Impl.ReplayDynamicMockState">
      <summary>
            Validate all expectations on a mock and ignores calls to
            any method that was not setup properly.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.ReplayDynamicMockState.#ctor(Rhino.Mocks.Impl.RecordDynamicMockState)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Impl.ReplayDynamicMockState" /> instance.
            </summary>
      <param name="previousState">The previous state for this method</param>
    </member>
    <member name="M:Rhino.Mocks.Impl.ReplayDynamicMockState.DoMethodCall(Castle.Core.Interceptor.IInvocation,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Add a method call for this state' mock.
            </summary>
      <param name="invocation">The invocation for this method</param>
      <param name="method">The method that was called</param>
      <param name="args">The arguments this method was called with</param>
    </member>
    <member name="M:Rhino.Mocks.Impl.ReplayDynamicMockState.BackToRecord">
      <summary>
            Gets a mock state that match the original mock state of the object.
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Impl.ReplayPartialMockState">
      <summary>
            Validate all expectations on a mock and ignores calls to
            any method that was not setup properly.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.ReplayPartialMockState.#ctor(Rhino.Mocks.Impl.RecordPartialMockState)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Impl.ReplayDynamicMockState" /> instance.
            </summary>
      <param name="previousState">The previous state for this method</param>
    </member>
    <member name="M:Rhino.Mocks.Impl.ReplayPartialMockState.DoMethodCall(Castle.Core.Interceptor.IInvocation,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Add a method call for this state' mock.
            </summary>
      <param name="invocation">The invocation for this method</param>
      <param name="method">The method that was called</param>
      <param name="args">The arguments this method was called with</param>
    </member>
    <member name="M:Rhino.Mocks.Impl.ReplayPartialMockState.BackToRecord">
      <summary>
            Gets a mock state that match the original mock state of the object.
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Impl.RhinoInterceptor">
      <summary>
            Summary description for RhinoInterceptor.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.RhinoInterceptor.#ctor(Rhino.Mocks.MockRepository,Rhino.Mocks.Interfaces.IMockedObject)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.Impl.RhinoInterceptor" /> instance.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.RhinoInterceptor.Intercept(Castle.Core.Interceptor.IInvocation)">
      <summary>
            Intercept a method call and direct it to the repository.
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Impl.Validate">
      <summary>
            Validate arguments for methods
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.Validate.IsNotNull(System.Object,System.String)">
      <summary>
            Validate that the passed argument is not null.
            </summary>
      <param name="obj">The object to validate</param>
      <param name="name">The name of the argument</param>
      <exception cref="T:System.ArgumentNullException">
            If the obj is null, an ArgumentNullException with the passed name
            is thrown.
            </exception>
    </member>
    <member name="M:Rhino.Mocks.Impl.Validate.ArgsEqual(System.Object[],System.Object[])">
      <summary>
            Validate that the arguments are equal.
            </summary>
      <param name="expectedArgs">Expected args.</param>
      <param name="actualArgs">Actual Args.</param>
    </member>
    <member name="M:Rhino.Mocks.Impl.Validate.AreEqual(System.Object,System.Object)">
      <summary>
            Validate that the two argument are equals, including validation for
            when the arguments are collections, in which case it will validate their values.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.Validate.SafeEquals(System.Object,System.Object)">
      <summary>
            This method is safe for use even if any of the objects is a mocked object
            that override equals.
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Impl.VerifiedMockState">
      <summary>
            Throw an object already verified when accessed
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.VerifiedMockState.#ctor(Rhino.Mocks.Interfaces.IMockState)">
      <summary>
            Create a new instance of VerifiedMockState 
            </summary>
      <param name="previous">The previous mock state, used to get the initial record state</param>
    </member>
    <member name="M:Rhino.Mocks.Impl.VerifiedMockState.MethodCall(Castle.Core.Interceptor.IInvocation,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Add a method call for this state' mock.
            </summary>
      <param name="invocation">The invocation for this method</param>
      <param name="method">The method that was called</param>
      <param name="args">The arguments this method was called with</param>
    </member>
    <member name="M:Rhino.Mocks.Impl.VerifiedMockState.Verify">
      <summary>
            Verify that this mock expectations have passed.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.VerifiedMockState.Replay">
      <summary>
            Verify that we can move to replay state and move 
            to the reply state.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.VerifiedMockState.BackToRecord">
      <summary>
            Gets a mock state that match the original mock state of the object.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.VerifiedMockState.GetLastMethodOptions``1">
      <summary>
            Get the options for the last method call
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Impl.VerifiedMockState.SetExceptionToThrowOnVerify(System.Exception)">
      <summary>
            Set the exception to throw when Verify is called.
            This is used to report exception that may have happened but where caught in the code.
            This way, they are reported anyway when Verify() is called.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Impl.VerifiedMockState.VerifyState">
      <summary>
            Gets the matching verify state for this state
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Impl.VerifiedMockState.LastMethodOptions">
      <summary>
            Get the options for the last method call
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Interfaces.IMethodRecorder">
      <summary>
            Records the actions on all the mocks created by a repository.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodRecorder.Record(System.Object,System.Reflection.MethodInfo,Rhino.Mocks.Interfaces.IExpectation)">
      <summary>
            Records the specified call with the specified args on the mocked object.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodRecorder.GetRecordedExpectation(Castle.Core.Interceptor.IInvocation,System.Object,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Get the expectation for this method on this object with this arguments 
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodRecorder.GetRepeatableExpectation(System.Object,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            This check the methods that were setup using the SetupResult.For()
            or LastCall.Repeat.Any() and that bypass the whole expectation model.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodRecorder.GetAllExpectationsForProxyAndMethod(System.Object,System.Reflection.MethodInfo)">
      <summary>
            Gets the all expectations for a mocked object and method combination,
            regardless of the expected arguments / callbacks / contraints.
            </summary>
      <param name="proxy">Mocked object.</param>
      <param name="method">Method.</param>
      <returns>List of all relevant expectation</returns>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodRecorder.GetAllExpectationsForProxy(System.Object)">
      <summary>
            Gets the all expectations for proxy.
            </summary>
      <param name="proxy">Mocked object.</param>
      <returns>List of all relevant expectation</returns>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodRecorder.RemoveAllRepeatableExpectationsForProxy(System.Object)">
      <summary>
            Removes all the repeatable expectations for proxy.
            </summary>
      <param name="proxy">Mocked object.</param>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodRecorder.ReplaceExpectation(System.Object,System.Reflection.MethodInfo,Rhino.Mocks.Interfaces.IExpectation,Rhino.Mocks.Interfaces.IExpectation)">
      <summary>
            Replaces the old expectation with the new expectation for the specified proxy/method pair.
            This replace ALL expectations that equal to old expectations.
            </summary>
      <param name="proxy">Proxy.</param>
      <param name="method">Method.</param>
      <param name="oldExpectation">Old expectation.</param>
      <param name="newExpectation">New expectation.</param>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodRecorder.AddRecorder(Rhino.Mocks.Interfaces.IMethodRecorder)">
      <summary>
            Adds the recorder and turn it into the active recorder.
            </summary>
      <param name="recorder">Recorder.</param>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodRecorder.MoveToPreviousRecorder">
      <summary>
            Moves to previous recorder.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodRecorder.GetRecordedExpectationOrNull(System.Object,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Gets the recorded expectation or null.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodRecorder.GetExpectedCallsMessage">
      <summary>
            Gets the next expected calls string.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodRecorder.MoveToParentReplayer">
      <summary>
            Moves to parent recorder.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodRecorder.AddToRepeatableMethods(System.Object,System.Reflection.MethodInfo,Rhino.Mocks.Interfaces.IExpectation)">
      <summary>
            Set the expectation so it can repeat any number of times.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodRecorder.RemoveExpectation(Rhino.Mocks.Interfaces.IExpectation)">
      <summary>
            Removes the expectation from the recorder
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodRecorder.ClearReplayerToCall(Rhino.Mocks.Interfaces.IMethodRecorder)">
      <summary>
            Clear the replayer to call (and all its chain of replayers)
            This also removes it from the list of expectations, so it will never be considered again
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Interfaces.IMethodRecorder.UnexpectedMethodCall(Castle.Core.Interceptor.IInvocation,System.Object,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Get the expectation for this method on this object with this arguments 
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Interfaces.IMethodRecorder.HasExpectations">
      <summary>
            Gets a value indicating whether this instance has expectations that weren't satisfied yet.
            </summary>
      <value>
        <c>true</c> if this instance has expectations; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Rhino.Mocks.LastCall">
      <summary>
            Allows to set various options for the last method call on
            a specified object.
            If the method has a return value, it's recommended to use Expect
            </summary>
    </member>
    <member name="M:Rhino.Mocks.LastCall.On(System.Object)">
      <summary>
            Allows to get an interface to work on the last call.
            </summary>
      <param name="mockedInstance">The mocked object</param>
      <returns>Interface that allows to set options for the last method call on this object</returns>
    </member>
    <member name="M:Rhino.Mocks.LastCall.Return``1(``0)">
      <summary>
            Set the return value for the method.
            </summary>
      <param name="objToReturn">The object the method will return</param>
      <returns>IRepeat that defines how many times the method will return this value</returns>
    </member>
    <member name="M:Rhino.Mocks.LastCall.Return(System.Object)">
      <summary>
            Set the return value for the method. This overload is needed for LastCall.Return(null)
            </summary>
      <param name="objToReturn">The object the method will return</param>
      <returns>IRepeat that defines how many times the method will return this value</returns>
    </member>
    <member name="M:Rhino.Mocks.LastCall.Throw(System.Exception)">
      <summary>
            Throws the specified exception when the method is called.
            </summary>
      <param name="exception">Exception to throw</param>
    </member>
    <member name="M:Rhino.Mocks.LastCall.IgnoreArguments">
      <summary>
            Ignores the arguments for this method. Any argument will be matched
            againt this method.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.LastCall.Constraints(Rhino.Mocks.Constraints.AbstractConstraint[])">
      <summary>
            Add constraints for the method's arguments.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.LastCall.Callback(System.Delegate)">
      <summary>
            Set a callback method for the last call
            </summary>
    </member>
    <member name="M:Rhino.Mocks.LastCall.CallOriginalMethod">
      <summary>
            Call the original method on the class, bypassing the mocking layers, for the last call.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.LastCall.CallOriginalMethod(Rhino.Mocks.Interfaces.OriginalCallOptions)">
      <summary>
            Call the original method on the class, optionally bypassing the mocking layers, for the last call.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.LastCall.Do(System.Delegate)">
      <summary>
            Set a delegate to be called when the expectation is matched.
            The delegate return value will be returned from the expectation.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.LastCall.GetEventRaiser">
      <summary>
            Gets an interface that will raise the last event when called.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.LastCall.OutRef(System.Object[])">
      <summary>
            Set the parameter values for out and ref parameters.
            This is done using zero based indexing, and _ignoring_ any non out/ref parameter.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.LastCall.Message(System.String)">
      <summary>
            Documentation message for the expectation
            </summary>
      <param name="documentationMessage">Message</param>
    </member>
    <member name="M:Rhino.Mocks.LastCall.PropertyBehavior">
      <summary>
            Use the property as a simple property, getting/setting the values without
            causing mock expectations.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.LastCall.Repeat">
      <summary>
            Better syntax to define repeats. 
            </summary>
    </member>
    <member name="T:Rhino.Mocks.MethodRecorders.MethodRecorderBase">
      <summary>
            Base class for method recorders, handle delegating to inner recorder if needed.
            </summary>
    </member>
    <member name="F:Rhino.Mocks.MethodRecorders.MethodRecorderBase.recordedActions">
      <summary>
            List of the expected actions on for this recorder
            The legal values are:
            	* Expectations
            	* Method Recorders
            </summary>
    </member>
    <member name="F:Rhino.Mocks.MethodRecorders.MethodRecorderBase.recorderToCall">
      <summary>
            The current recorder.
            </summary>
    </member>
    <member name="F:Rhino.Mocks.MethodRecorders.MethodRecorderBase.replayerToCall">
      <summary>
            The current replayer;
            </summary>
    </member>
    <member name="F:Rhino.Mocks.MethodRecorders.MethodRecorderBase.parentRecorder">
      <summary>
            The parent recorder of this one, may be null.
            </summary>
    </member>
    <member name="F:Rhino.Mocks.MethodRecorders.MethodRecorderBase.replayersToIgnoreForThisCall">
      <summary>
            This contains a list of all the replayers that should be ignored
            for a spesific method call. A replayer gets into this list by calling 
            ClearReplayerToCall() on its parent. This list is Clear()ed on each new invocation.
            </summary>
    </member>
    <member name="F:Rhino.Mocks.MethodRecorders.MethodRecorderBase.repeatableMethods">
      <summary>
            All the repeatable methods calls.
            </summary>
    </member>
    <member name="F:Rhino.Mocks.MethodRecorders.MethodRecorderBase.recursionDepth">
      <summary>
            Counts the recursion depth of the current expectation search stack
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.MethodRecorderBase.#ctor(Rhino.Mocks.Generated.ProxyMethodExpectationsDictionary)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.MethodRecorders.MethodRecorderBase" /> instance.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.MethodRecorderBase.#ctor(Rhino.Mocks.Interfaces.IMethodRecorder,Rhino.Mocks.Generated.ProxyMethodExpectationsDictionary)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.MethodRecorders.MethodRecorderBase" /> instance.
            </summary>
      <param name="parentRecorder">Parent recorder.</param>
      <param name="repeatableMethods">Repeatable methods</param>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.MethodRecorderBase.Record(System.Object,System.Reflection.MethodInfo,Rhino.Mocks.Interfaces.IExpectation)">
      <summary>
            Records the specified call with the specified args on the mocked object.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.MethodRecorderBase.GetRecordedExpectation(Castle.Core.Interceptor.IInvocation,System.Object,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Get the expectation for this method on this object with this arguments 
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.MethodRecorderBase.GetAllExpectationsForProxyAndMethod(System.Object,System.Reflection.MethodInfo)">
      <summary>
            Gets the all expectations for a mocked object and method combination,
            regardless of the expected arguments / callbacks / contraints.
            </summary>
      <param name="proxy">Mocked object.</param>
      <param name="method">Method.</param>
      <returns>List of all relevant expectation</returns>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.MethodRecorderBase.GetAllExpectationsForProxy(System.Object)">
      <summary>
            Gets the all expectations for proxy.
            </summary>
      <param name="proxy">Mocked object.</param>
      <returns>List of all relevant expectation</returns>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.MethodRecorderBase.ReplaceExpectation(System.Object,System.Reflection.MethodInfo,Rhino.Mocks.Interfaces.IExpectation,Rhino.Mocks.Interfaces.IExpectation)">
      <summary>
            Replaces the old expectation with the new expectation for the specified proxy/method pair.
            This replace ALL expectations that equal to old expectations.
            </summary>
      <param name="proxy">Proxy.</param>
      <param name="method">Method.</param>
      <param name="oldExpectation">Old expectation.</param>
      <param name="newExpectation">New expectation.</param>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.MethodRecorderBase.RemoveAllRepeatableExpectationsForProxy(System.Object)">
      <summary>
            Remove the all repeatable expectations for proxy.
            </summary>
      <param name="proxy">Mocked object.</param>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.MethodRecorderBase.AddToRepeatableMethods(System.Object,System.Reflection.MethodInfo,Rhino.Mocks.Interfaces.IExpectation)">
      <summary>
            Set the expectation so it can repeat any number of times.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.MethodRecorderBase.RemoveExpectation(Rhino.Mocks.Interfaces.IExpectation)">
      <summary>
            Removes the expectation from the recorder
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.MethodRecorderBase.AddRecorder(Rhino.Mocks.Interfaces.IMethodRecorder)">
      <summary>
            Adds the recorder and turn it into the active recorder.
            </summary>
      <param name="recorder">Recorder.</param>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.MethodRecorderBase.MoveToPreviousRecorder">
      <summary>
            Moves to previous recorder.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.MethodRecorderBase.MoveToParentReplayer">
      <summary>
            Moves to parent recorder.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.MethodRecorderBase.GetRecordedExpectationOrNull(System.Object,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Gets the recorded expectation or null.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.MethodRecorderBase.ClearReplayerToCall(Rhino.Mocks.Interfaces.IMethodRecorder)">
      <summary>
            Clear the replayer to call (and all its chain of replayers).
            This also removes it from the list of expectations, so it will never be considered again
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.MethodRecorderBase.UnexpectedMethodCall(Castle.Core.Interceptor.IInvocation,System.Object,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Get the expectation for this method on this object with this arguments 
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.MethodRecorderBase.GetExpectedCallsMessage">
      <summary>
            Gets the next expected calls string.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.MethodRecorderBase.DoGetRecordedExpectationOrNull(System.Object,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Handles the real getting of the recorded expectation or null.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.MethodRecorderBase.DoRecord(System.Object,System.Reflection.MethodInfo,Rhino.Mocks.Interfaces.IExpectation)">
      <summary>
            Handle the real execution of this method for the derived class
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.MethodRecorderBase.DoGetRecordedExpectation(Castle.Core.Interceptor.IInvocation,System.Object,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Handle the real execution of this method for the derived class
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.MethodRecorderBase.DoGetAllExpectationsForProxy(System.Object)">
      <summary>
            Handle the real execution of this method for the derived class
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.MethodRecorderBase.DoReplaceExpectation(System.Object,System.Reflection.MethodInfo,Rhino.Mocks.Interfaces.IExpectation,Rhino.Mocks.Interfaces.IExpectation)">
      <summary>
            Handle the real execution of this method for the derived class
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.MethodRecorderBase.DoRemoveExpectation(Rhino.Mocks.Interfaces.IExpectation)">
      <summary>
            Handle the real execution of this method for the derived class
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.MethodRecorderBase.DoAddRecorder(Rhino.Mocks.Interfaces.IMethodRecorder)">
      <summary>
            Handle the real execution of this method for the derived class
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.MethodRecorderBase.ShouldConsiderThisReplayer(Rhino.Mocks.Interfaces.IMethodRecorder)">
      <summary>
            Should this replayer be considered valid for this call?
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.MethodRecorderBase.GetRepeatableExpectation(System.Object,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            This check the methods that were setup using the SetupResult.For()
            or LastCall.Repeat.Any() and that bypass the whole expectation model.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.MethodRecorders.MethodRecorderBase.HasExpectations">
      <summary>
            Gets a value indicating whether this instance has expectations that weren't satisfied yet.
            </summary>
      <value>
        <c>true</c> if this instance has expectations; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Rhino.Mocks.MethodRecorders.MethodRecorderBase.DoHasExpectations">
      <summary>
            Handle the real execution of this method for the derived class
            </summary>
    </member>
    <member name="T:Rhino.Mocks.MethodRecorders.UnorderedMethodRecorder">
      <summary>
            Unordered collection of method records, any expectation that exist
            will be matched.
            </summary>
    </member>
    <member name="F:Rhino.Mocks.MethodRecorders.UnorderedMethodRecorder.parentRecorderRedirection">
      <summary>
            The parent recorder we have redirected to.
            Useful for certain edge cases in orderring.
            See: FieldProblem_Entropy for the details.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.UnorderedMethodRecorder.#ctor(Rhino.Mocks.Interfaces.IMethodRecorder,Rhino.Mocks.Generated.ProxyMethodExpectationsDictionary)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.MethodRecorders.UnorderedMethodRecorder" /> instance.
            </summary>
      <param name="parentRecorder">Parent recorder.</param>
      <param name="repeatableMethods">Repeatable methods</param>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.UnorderedMethodRecorder.#ctor(Rhino.Mocks.Generated.ProxyMethodExpectationsDictionary)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.MethodRecorders.UnorderedMethodRecorder" /> instance.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.UnorderedMethodRecorder.DoRecord(System.Object,System.Reflection.MethodInfo,Rhino.Mocks.Interfaces.IExpectation)">
      <summary>
            Records the specified call with the specified args on the mocked object.
            </summary>
      <param name="proxy">Mocked object.</param>
      <param name="method">Method.</param>
      <param name="expectation">Expectation.</param>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.UnorderedMethodRecorder.DoGetRecordedExpectation(Castle.Core.Interceptor.IInvocation,System.Object,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Get the expectation for this method on this object with this arguments 
            </summary>
      <param name="invocation">Invocation for this method</param>
      <param name="proxy">Mocked object.</param>
      <param name="method">Method.</param>
      <param name="args">Args.</param>
      <returns>True is the call was recorded, false otherwise</returns>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.UnorderedMethodRecorder.GetAllExpectationsForProxyAndMethod(System.Object,System.Reflection.MethodInfo)">
      <summary>
            Gets the all expectations for a mocked object and method combination,
            regardless of the expected arguments / callbacks / contraints.
            </summary>
      <param name="proxy">Mocked object.</param>
      <param name="method">Method.</param>
      <returns>List of all relevant expectation</returns>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.UnorderedMethodRecorder.DoGetAllExpectationsForProxy(System.Object)">
      <summary>
            Gets the all expectations for proxy.
            </summary>
      <param name="proxy">Mocked object.</param>
      <returns>List of all relevant expectation</returns>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.UnorderedMethodRecorder.DoReplaceExpectation(System.Object,System.Reflection.MethodInfo,Rhino.Mocks.Interfaces.IExpectation,Rhino.Mocks.Interfaces.IExpectation)">
      <summary>
            Replaces the old expectation with the new expectation for the specified proxy/method pair.
            This replace ALL expectations that equal to old expectations.
            </summary>
      <param name="proxy">Proxy.</param>
      <param name="method">Method.</param>
      <param name="oldExpectation">Old expectation.</param>
      <param name="newExpectation">New expectation.</param>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.UnorderedMethodRecorder.DoRemoveExpectation(Rhino.Mocks.Interfaces.IExpectation)">
      <summary>
            Handle the real execution of this method for the derived class
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.UnorderedMethodRecorder.DoGetRecordedExpectationOrNull(System.Object,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Handles the real getting of the recorded expectation or null.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.UnorderedMethodRecorder.DoAddRecorder(Rhino.Mocks.Interfaces.IMethodRecorder)">
      <summary>
            Handle the real execution of this method for the derived class
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.UnorderedMethodRecorder.GetExpectedCallsMessage">
      <summary>
            Gets the next expected calls string.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.UnorderedMethodRecorder.UnexpectedMethodCall(Castle.Core.Interceptor.IInvocation,System.Object,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Create an exception for an unexpected method call.
            </summary>
    </member>
    <member name="P:Rhino.Mocks.MethodRecorders.UnorderedMethodRecorder.DoHasExpectations">
      <summary>
            Gets a value indicating whether this instance has expectations that weren't satisfied yet.
            </summary>
      <value>
        <c>true</c> if this instance has expectations; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Rhino.Mocks.MethodRecorders.OrderedMethodRecorder">
      <summary>
            Ordered collection of methods, methods must arrive in specified order
            in order to pass.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.OrderedMethodRecorder.#ctor(Rhino.Mocks.Interfaces.IMethodRecorder,Rhino.Mocks.Generated.ProxyMethodExpectationsDictionary)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.MethodRecorders.OrderedMethodRecorder" /> instance.
            </summary>
      <param name="parentRecorder">Parent recorder.</param>
      <param name="repeatableMethods">Repetable methods</param>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.OrderedMethodRecorder.#ctor(Rhino.Mocks.Generated.ProxyMethodExpectationsDictionary)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.MethodRecorders.OrderedMethodRecorder" /> instance.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.OrderedMethodRecorder.DoGetRecordedExpectationOrNull(System.Object,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Handles the real getting of the recorded expectation or null.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.OrderedMethodRecorder.UnexpectedMethodCall(Castle.Core.Interceptor.IInvocation,System.Object,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Get the expectation for this method on this object with this arguments 
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.OrderedMethodRecorder.GetExpectedCallsMessage">
      <summary>
            Gets the next expected calls string.
            </summary>
    </member>
    <member name="T:Rhino.Mocks.MethodRecorders.ProxyMethodExpectationTriplet">
      <summary>
            Hold an expectation for a method call on an object
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.ProxyMethodExpectationTriplet.#ctor(System.Object,System.Reflection.MethodInfo,Rhino.Mocks.Interfaces.IExpectation)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.MethodRecorders.ProxyMethodExpectationTriplet" /> instance.
            </summary>
      <param name="proxy">Proxy.</param>
      <param name="method">Method.</param>
      <param name="expectation">Expectation.</param>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.ProxyMethodExpectationTriplet.Equals(System.Object)">
      <summary>
            Determains if the object equal to this instance
            </summary>
      <param name="obj">Obj.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.ProxyMethodExpectationTriplet.GetHashCode">
      <summary>
            Gets the hash code.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Rhino.Mocks.MethodRecorders.ProxyMethodExpectationTriplet.Proxy">
      <summary>
            Gets the proxy.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Rhino.Mocks.MethodRecorders.ProxyMethodExpectationTriplet.Method">
      <summary>
            Gets the method.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Rhino.Mocks.MethodRecorders.ProxyMethodExpectationTriplet.Expectation">
      <summary>
            Gets the expectation.
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Rhino.Mocks.MethodRecorders.ProxyMethodPair">
      <summary>
            Holds a pair of mocked object and a method
            and allows to compare them against each other.
            This allows us to have a distinction between mockOne.MyMethod() and
            mockTwo.MyMethod()...
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.ProxyMethodPair.#ctor(System.Object,System.Reflection.MethodInfo)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.MethodRecorders.ProxyMethodPair" /> instance.
            </summary>
      <param name="proxy">Proxy.</param>
      <param name="method">Method.</param>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.ProxyMethodPair.Equals(System.Object)">
      <summary>
            Determains whatever obj equals to this instance.
            ProxyMethodPairs are equals when they point to the same /instance/ of
            an object, and to the same method.
            </summary>
      <param name="obj">Obj.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.ProxyMethodPair.GetHashCode">
      <summary>
            Gets the hash code.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Rhino.Mocks.MethodRecorders.ProxyMethodPair.Proxy">
      <summary>
            Gets the proxy.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Rhino.Mocks.MethodRecorders.ProxyMethodPair.Method">
      <summary>
            Gets the method.
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Rhino.Mocks.MethodRecorders.RecorderChanger">
      <summary>
            Change the recorder from ordered to unordered and vice versa
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.RecorderChanger.#ctor(Rhino.Mocks.MockRepository,Rhino.Mocks.Interfaces.IMethodRecorder,Rhino.Mocks.Interfaces.IMethodRecorder)">
      <summary>
            Creates a new <see cref="T:Rhino.Mocks.MethodRecorders.RecorderChanger" /> instance.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.MethodRecorders.RecorderChanger.Dispose">
      <summary>
            Disposes this instance.
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Mocker">
      <summary>
            Accessor for the current mocker
            </summary>
    </member>
    <member name="P:Rhino.Mocks.Mocker.Current">
      <summary>
            The current mocker
            </summary>
    </member>
    <member name="T:Rhino.Mocks.RhinoMocks">
      <summary>
            Used for [assembly: InternalsVisibleTo(RhinoMocks.StrongName)]
            Used for [assembly: InternalsVisibleTo(RhinoMocks.NormalName)]
            </summary>
    </member>
    <member name="F:Rhino.Mocks.RhinoMocks.StrongName">
      <summary>
            Strong name for the Dynamic Proxy assemblies. Used for InternalsVisibleTo specification.
            </summary>
    </member>
    <member name="F:Rhino.Mocks.RhinoMocks.NormalName">
      <summary>
            Normal name for dynamic proxy assemblies. Used for InternalsVisibleTo specification.
            </summary>
    </member>
    <member name="F:Rhino.Mocks.RhinoMocks.Logger">
      <summary>
            Logs all method calls for methods
            </summary>
    </member>
    <member name="T:Rhino.Mocks.SetupResult">
      <summary>
            Setup method calls to repeat any number of times.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.SetupResult.For``1(``0)">
      <summary>
            Get the method options and set the last method call to repeat 
            any number of times.
            This also means that the method would transcend ordering
            </summary>
    </member>
    <member name="M:Rhino.Mocks.SetupResult.On(System.Object)">
      <summary>
            Get the method options for the last method call on the mockInstance and set it
            to repeat any number of times.
            This also means that the method would transcend ordering
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Utilities.MethodCallUtil">
      <summary>
            Utility class for working with method calls.
            </summary>
    </member>
    <member name="T:Rhino.Mocks.Utilities.MethodCallUtil.FormatArgumnet">
      <summary>
            Delegate to format the argument for the string representation of
            the method call.
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Utilities.MethodCallUtil.StringPresentation(Castle.Core.Interceptor.IInvocation,Rhino.Mocks.Utilities.MethodCallUtil.FormatArgumnet,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Return the string representation of a method call and its arguments.
            </summary>
      <param name="method">The method</param>
      <param name="args">The method arguments</param>
      <param name="invocation">Invocation of the method, used to get the generics arguments</param>
      <param name="format">Delegate to format the parameter</param>
      <returns>The string representation of this method call</returns>
    </member>
    <member name="M:Rhino.Mocks.Utilities.MethodCallUtil.StringPresentation(Castle.Core.Interceptor.IInvocation,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Return the string representation of a method call and its arguments.
            </summary>
      <param name="invocation">The invocation of the method, used to get the generic parameters</param>
      <param name="method">The method</param>
      <param name="args">The method arguments</param>
      <returns>The string representation of this method call</returns>
    </member>
    <member name="T:Rhino.Mocks.Utilities.ReturnValueUtil">
      <summary>
            Utility to get the default value for a type
            </summary>
    </member>
    <member name="M:Rhino.Mocks.Utilities.ReturnValueUtil.DefaultValue(System.Type,Castle.Core.Interceptor.IInvocation)">
      <summary>
            The default value for a type.
            Null for reference types and void
            0 for value types.
            First element for enums
            Note that we need to get the value even for opened generic types, such as those from
            generic methods.
            </summary>
      <param name="type">Type.</param>
      <param name="invocation">The invocation.</param>
      <returns>the default value</returns>
    </member>
    <member name="T:Rhino.Mocks.With">
      <summary>
            Allows easier access to MockRepository, works closely with Mocker.Current to
            allow access to a context where the mock repository is automatially verified at
            the end of the code block.
            </summary>
    </member>
    <member name="T:Rhino.Mocks.With.Proc">
      <summary>
            A method with no arguments and no return value that will be called under the mock context.
            </summary>
    </member>
    <member name="T:Rhino.Mocks.With.IMockVerifier">
      <summary>
            Interface to verify previously defined expectations
            </summary>
    </member>
    <member name="M:Rhino.Mocks.With.IMockVerifier.Verify(Rhino.Mocks.With.Proc)">
      <summary>
            Verifies if a piece of code
            </summary>
    </member>
    <member name="T:Rhino.Mocks.With.FluentMocker">
      <summary>
            FluentMocker implements some kind of fluent interface attempt
            for saying "With the Mocks [mocks], Expecting (in same order) [things] verify [that]."
            </summary>
    </member>
    <member name="M:Rhino.Mocks.With.FluentMocker.Expecting(Rhino.Mocks.With.Proc)">
      <summary>
            Defines unordered expectations
            </summary>
      <param name="methodCallsDescribingExpectations">A delegate describing the expectations</param>
      <returns>an IMockVerifier</returns>
    </member>
    <member name="M:Rhino.Mocks.With.FluentMocker.ExpectingInSameOrder(Rhino.Mocks.With.Proc)">
      <summary>
            Defines ordered expectations
            </summary>
      <param name="methodCallsDescribingExpectations">A delegate describing the expectations</param>
      <returns>an IMockVerifier</returns>
    </member>
    <member name="M:Rhino.Mocks.With.FluentMocker.Verify(Rhino.Mocks.With.Proc)">
      <summary>
            Verifies previously defined expectations
            </summary>
    </member>
    <member name="M:Rhino.Mocks.With.Mocks(Rhino.Mocks.With.Proc)">
      <summary>
            Initialize a code block where Mocker.Current is initialized.
            At the end of the code block, all the expectation will be verified.
            This overload will create a new MockRepository.
            </summary>
      <param name="methodCallThatHasMocks">The code that will be executed under the mock context</param>
    </member>
    <member name="M:Rhino.Mocks.With.Mocks(Rhino.Mocks.MockRepository,Rhino.Mocks.With.Proc)">
      <summary>
            Initialize a code block where Mocker.Current is initialized.
            At the end of the code block, all the expectation will be verified.
            This overload will create a new MockRepository.
            </summary>
      <param name="mocks">The mock repository to use, at the end of the code block, VerifyAll() will be called on the repository.</param>
      <param name="methodCallThatHasMocks">The code that will be executed under the mock context</param>
    </member>
    <member name="M:Rhino.Mocks.With.Mocks(Rhino.Mocks.MockRepository)">
      <summary>
            Create a FluentMocker
            </summary>
      <param name="mocks">The mock repository to use.</param>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.IndirectReference">
      <summary>
            Wraps a reference that is passed 
            ByRef and provides indirect load/store support.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.NewArrayExpression">
      <summary>
            Summary description for NewArrayExpression.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.ReferencesToObjectArrayExpression">
      <summary>
      </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.CustomAttributeUtil.InitializeConstructorArgs(System.Type,System.Attribute,System.Object[],System.Reflection.ParameterInfo[])">
      <summary>
            Here we try to match a constructor argument to its value.
            Since we can't get the values from the assembly, we use some heuristics to get it.
            a/ we first try to match all the properties on the attributes by name (case insensitive) to the argument
            b/ if we fail we try to match them by property type, with some smarts about convertions (i,e: can use Guid for string).
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.CustomAttributeUtil.ReplaceIfBetterMatch(System.Reflection.ParameterInfo,System.Reflection.PropertyInfo,System.Reflection.PropertyInfo)">
      <summary>
            We have the following rules here.
            Try to find a matching type, failing that, if the parameter is string, get the first property (under the assumption that
            we can convert it.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.CustomAttributeUtil.ConvertValue(System.Object,System.Type)">
      <summary>
            Attributes can only accept simple types, so we return null for null,
            if the value is passed as string we call to string (should help with converting), 
            otherwise, we use the value as is (enums, integer, etc).
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.LdcOpCodesDictionary">
      <summary>
            Provides appropriate Ldc.X opcode for the type of primitive value to be loaded.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.LdindOpCodesDictionary">
      <summary>
            Provides appropriate Ldind.X opcode for 
            the type of primitive value to be loaded indirectly.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.MethodEmitter.CopyParametersAndReturnTypeFrom(System.Reflection.MethodInfo,Castle.DynamicProxy.Generators.Emitters.AbstractTypeEmitter)">
      <summary>
            Inspect the base method for generic definitions
            and set the return type and the parameters
            accordingly
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadOpCodeForConstantValue(System.Reflection.Emit.ILGenerator,System.Object)">
      <summary>
            Emits a load opcode of the appropriate kind for a constant string or
            primitive value.
            </summary>
      <param name="gen">
      </param>
      <param name="value">
      </param>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadOpCodeForDefaultValueOfType(System.Reflection.Emit.ILGenerator,System.Type)">
      <summary>
            Emits a load opcode of the appropriate kind for the constant default value of a
            type, such as 0 for value types and null for reference types.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadIndirectOpCodeForType(System.Reflection.Emit.ILGenerator,System.Type)">
      <summary>
            Emits a load indirect opcode of the appropriate type for a value or object reference.
            Pops a pointer off the evaluation stack, dereferences it and loads
            a value of the specified type.
            </summary>
      <param name="gen">
      </param>
      <param name="type">
      </param>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitStoreIndirectOpCodeForType(System.Reflection.Emit.ILGenerator,System.Type)">
      <summary>
            Emits a store indirectopcode of the appropriate type for a value or object reference.
            Pops a value of the specified type and a pointer off the evaluation stack, and
            stores the value.
            </summary>
      <param name="gen">
      </param>
      <param name="type">
      </param>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.PropertiesCollection">
      <summary>
            Summary description for PropertiesCollection.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.StindOpCodesDictionary">
      <summary>
            Provides appropriate Stind.X opcode 
            for the type of primitive value to be stored indirectly.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.BaseProxyGenerator">
      <summary>
            Base class that exposes the common functionalities
            to proxy generation.
            </summary>
      <remarks>
            TODO: 
            - Use the interceptor selector if provided
            - Add tests and fixes for 'leaking this' problem
            - Mixin support
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.GetProxyTargetReference">
      <summary>
            Used by dinamically implement <see cref="T:Castle.Core.Interceptor.IProxyTargetAccessor" /></summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.GenerateParameterlessConstructor(Castle.DynamicProxy.Generators.Emitters.ClassEmitter,System.Type,Castle.DynamicProxy.Generators.Emitters.SimpleAST.FieldReference)">
      <summary>
            Generates a parameters constructor that initializes the proxy
            state with <see cref="T:Castle.Core.Interceptor.StandardInterceptor" /> just to make it non-null.
            <para>
            This constructor is important to allow proxies to be XML serializable
            </para></summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.BuildInvocationNestedType(Castle.DynamicProxy.Generators.Emitters.ClassEmitter,System.Type,System.Type,System.Reflection.MethodInfo,System.Reflection.MethodInfo,Castle.DynamicProxy.Generators.ConstructorVersion)">
      <summary>
            If callbackMethod is null the InvokeOnTarget implementation 
            is just the code to throw an exception
            </summary>
      <param name="emitter">
      </param>
      <param name="targetType">
      </param>
      <param name="targetForInvocation">
      </param>
      <param name="methodInfo">
      </param>
      <param name="callbackMethod">
      </param>
      <param name="version">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.BuildInvocationNestedType(Castle.DynamicProxy.Generators.Emitters.ClassEmitter,System.Type,System.Type,System.Reflection.MethodInfo,System.Reflection.MethodInfo,Castle.DynamicProxy.Generators.ConstructorVersion,System.Boolean)">
      <summary>
            If callbackMethod is null the InvokeOnTarget implementation
            is just the code to throw an exception
            </summary>
      <param name="emitter">
      </param>
      <param name="targetType">
      </param>
      <param name="targetForInvocation">
      </param>
      <param name="methodInfo">
      </param>
      <param name="callbackMethod">
      </param>
      <param name="version">
      </param>
      <param name="allowChangeTarget">If true the invocation will implement the IChangeProxyTarget interface</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.CreateIInvocationConstructor(System.Type,Castle.DynamicProxy.Generators.Emitters.NestedClassEmitter,Castle.DynamicProxy.Generators.Emitters.SimpleAST.FieldReference,Castle.DynamicProxy.Generators.ConstructorVersion)">
      <summary>
            Generates the constructor for the nested class that extends
            <see cref="T:Castle.DynamicProxy.AbstractInvocation" /></summary>
      <param name="targetFieldType">
      </param>
      <param name="nested">
      </param>
      <param name="targetField">
      </param>
      <param name="version">
      </param>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.CreateInitializeCacheMethodBody(System.Type,System.Reflection.MethodInfo[],Castle.DynamicProxy.Generators.Emitters.ClassEmitter,Castle.DynamicProxy.Generators.Emitters.ConstructorEmitter)">
      <summary>
            Improvement: this cache should be static. We should generate a
            type constructor instead
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.AcceptMethod(System.Reflection.MethodInfo,System.Boolean)">
      <summary>
            Performs some basic screening and invokes the <see cref="T:Castle.DynamicProxy.IProxyGenerationHook" />
            to select methods.
            </summary>
      <param name="method">
      </param>
      <param name="onlyVirtuals">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.IsAccessible(System.Reflection.MethodInfo)">
      <summary>
            Checks if the method is public or protected.
            </summary>
      <param name="method">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.ShouldSkipAttributeReplication(System.Attribute)">
      <summary>
            Attributes should be replicated if they are non-inheritable,
            but there are some special cases where the attributes means
            something to the CLR, where they should be skipped.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.ShouldCreateNewSlot(System.Reflection.MethodInfo)">
      <summary>
            Checks if the method has the same signature as a method that was marked as
            one that should generate a new vtable slot.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.CacheKey.#ctor(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.Generators.CacheKey" /> class.
            </summary>
      <param name="targetType">Type of the target.</param>
      <param name="interfaces">The interfaces.</param>
      <param name="options">The options.</param>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.ClassProxyGenerator">
      <summary>
      </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.EventToGenerate.#ctor(Castle.DynamicProxy.Generators.Emitters.EventEmitter,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Reflection.EventAttributes)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.Generators.EventToGenerate" /> class.
            </summary>
      <param name="emitter">The emitter.</param>
      <param name="addMethod">The add method.</param>
      <param name="removeMethod">The remove method.</param>
      <param name="attributes">The attributes.</param>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetGenerator">
      <summary>
      </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetGenerator.FindMethodOnTargetType(System.Reflection.MethodInfo,System.Type)">
      <summary>
            Finds the type of the method on target.
            </summary>
      <param name="methodOnInterface">The method on interface.</param>
      <param name="proxyTargetType">Type of the proxy target.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetGenerator.IsTypeEquivalent(System.Type,System.Type)">
      <summary>
            Checks whether the given types are the same. This is 
            more complicated than it looks.
            </summary>
      <param name="sourceType">
      </param>
      <param name="targetType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.InterfaceGeneratorType">
      <summary>
            This is used by the ProxyObjectReference class durin de-serialiation, to know
            which generator it should use
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.MethodFinder">
      <summary>
            Returns the methods implemented by a type. Use this instead of Type.GetMethods() to work around a CLR issue
            where duplicate MethodInfos are returned by Type.GetMethods() after a token of a generic type's method was loaded.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Serialization.ProxyObjectReference">
      <summary>
            Handles the deserialization of proxies.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Serialization.ProxyObjectReference.ResetScope">
      <summary>
            Usefull for test cases
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.IProxyGenerationHook">
      <summary>
            Used during the target type inspection process.
            Implementors have a chance to interfere in the
            proxy generation process
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyGenerationHook.ShouldInterceptMethod(System.Type,System.Reflection.MethodInfo)">
      <summary>
            Invoked by the generation process to know if
            the specified member should be proxied
            </summary>
      <param name="type">
      </param>
      <param name="memberInfo">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyGenerationHook.NonVirtualMemberNotification(System.Type,System.Reflection.MemberInfo)">
      <summary>
            Invoked by the generation process to notify that a
            member wasn't marked as virtual.
            </summary>
      <param name="type">
      </param>
      <param name="memberInfo">
      </param>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyGenerationHook.MethodsInspected">
      <summary>
            Invoked by the generation process to notify 
            that the whole process is completed.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.IProxyBuilder">
      <summary>
            Abstracts the implementation of proxy constructions
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateClassProxy(System.Type,Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
            Implementors should return a proxy for the specified type.
            </summary>
      <param name="theClass">The proxy base class.</param>
      <param name="options">The proxy generation options.</param>
      <returns>The generated proxy type.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
            Implementors should return a proxy for the specified
            type and interfaces. The interfaces must be only "mark" interfaces
            </summary>
      <param name="theClass">
      </param>
      <param name="interfaces">
      </param>
      <param name="options">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithTarget(System.Type,System.Type[],System.Type,Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
            Implementors should return a proxy for the specified
            interface that 'proceeds' executions to the 
            specified target.
            </summary>
      <param name="theInterface">
      </param>
      <param name="interfaces">
      </param>
      <param name="targetType">
      </param>
      <param name="options">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
            Implementors should return a proxy for the specified
            interface that delegate all executions to the 
            specified interceptor(s).
            </summary>
      <param name="theInterface">
      </param>
      <param name="interfaces">
      </param>
      <param name="options">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithTargetInterface(System.Type,Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
            Implementors should return a proxy for the specified
            interface that delegate all executions to the
            specified interceptor(s) and uses an instance of the interface
            as their targets, rather than a class. All IInvocation's
            should then implement IChangeProxyTarget.
            </summary>
      <param name="theInterface">
      </param>
      <param name="options">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.DynamicProxy.IProxyBuilder.ModuleScope">
      <summary>
            Gets the module scope used by this builder for generating code.
            </summary>
      <value>The module scope used by this builder.</value>
    </member>
    <member name="M:Castle.DynamicProxy.InternalsHelper.IsInternalToDynamicProxy(System.Reflection.Assembly)">
      <summary>
            Determines whether this assembly has internals visisble to dynamic proxy.
            </summary>
      <param name="asm">The asm.</param>
    </member>
    <member name="M:Castle.DynamicProxy.InternalsHelper.IsInternal(System.Reflection.MethodInfo)">
      <summary>
            Determines whether the specified method is internal.
            </summary>
      <param name="method">The method.</param>
      <returns>
        <c>true</c> if the specified method is internal; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Castle.DynamicProxy.ModuleScope">
      <summary>
            Summary description for ModuleScope.
            </summary>
    </member>
    <member name="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME">
      <summary>
            The default file name used when the assembly is saved using <see cref="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME" />.
            </summary>
    </member>
    <member name="F:Castle.DynamicProxy.ModuleScope.DEFAULT_ASSEMBLY_NAME">
      <summary>
            The default assembly (simple) name used for the assemblies generated by a <see cref="T:Castle.DynamicProxy.ModuleScope" /> instance.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class; assemblies created by this instance will not be saved.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
            should be saved.
            </summary>
      <param name="savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean,System.String,System.String,System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
            should be saved and what simple names are to be assigned to them.
            </summary>
      <param name="savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
      <param name="strongAssemblyName">The simple name of the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="strongModulePath">The path and file name of the manifest module of the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="weakAssemblyName">The simple name of the weak-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="weakModulePath">The path and file name of the manifest module of the weak-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.GetFromCache(Castle.DynamicProxy.Generators.CacheKey)">
      <summary>
            Returns a type from this scope's type cache, or null if the key cannot be found.
            </summary>
      <param name="key">The key to be looked up in the cache.</param>
      <returns>The type from this scope's type cache matching the key, or null if the key cannot be found</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.RegisterInCache(Castle.DynamicProxy.Generators.CacheKey,System.Type)">
      <summary>
            Registers a type in this scope's type cache.
            </summary>
      <param name="key">The key to be associated with the type.</param>
      <param name="type">The type to be stored in the cache.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.GetKeyPair">
      <summary>
            Gets the key pair used to sign the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.ObtainDynamicModule(System.Boolean)">
      <summary>
            Gets the specified module generated by this scope, creating a new one if none has yet been generated.
            </summary>
      <param name="isStrongNamed">If set to true, a strong-named module is returned; otherwise, a weak-named module is returned.</param>
      <returns>A strong-named or weak-named module generated by this scope, as specified by the <paramref name="isStrongNamed" /> parameter.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.ObtainDynamicModuleWithStrongName">
      <summary>
            Gets the strong-named module generated by this scope, creating a new one if none has yet been generated.
            </summary>
      <returns>A strong-named module generated by this scope.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.ObtainDynamicModuleWithWeakName">
      <summary>
            Gets the weak-named module generated by this scope, creating a new one if none has yet been generated.
            </summary>
      <returns>A weak-named module generated by this scope.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.SaveAssembly">
      <summary>
            Saves the generated assembly with the name and directory information given when this <see cref="T:Castle.DynamicProxy.ModuleScope" /> instance was created (or with
            the <see cref="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME" /> and current directory if none was given).
            </summary>
      <remarks>
        <para>
            This method stores the generated assembly in the directory passed as part of the module information specified when this instance was
            constructed (if any, else the current directory is used). If both a strong-named and a weak-named assembly
            have been generated, it will throw an exception; in this case, use the <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly(System.Boolean)" /> overload.
            </para>
        <para>
            If this <see cref="T:Castle.DynamicProxy.ModuleScope" /> was created without indicating that the assembly should be saved, this method does nothing.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">Both a strong-named and a weak-named assembly have been generated or no assembly has been
            generated.</exception>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.SaveAssembly(System.Boolean)">
      <summary>
            Saves the specified generated assembly with the name and directory information given when this <see cref="T:Castle.DynamicProxy.ModuleScope" /> instance was created
            (or with the <see cref="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME" /> and current directory if none was given).
            </summary>
      <param name="strongNamed">True if the generated assembly with a strong name should be saved (see <see cref="P:Castle.DynamicProxy.ModuleScope.StrongNamedModule" />);
              false if the generated assembly without a strong name should be saved (see <see cref="P:Castle.DynamicProxy.ModuleScope.WeakNamedModule" />.</param>
      <remarks>
        <para>
            This method stores the specified generated assembly in the directory passed as part of the module information specified when this instance was
            constructed (if any, else the current directory is used).
            </para>
        <para>
            If this <see cref="T:Castle.DynamicProxy.ModuleScope" /> was created without indicating that the assembly should be saved, this method does nothing.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">No assembly has been generated that matches the <paramref name="strongNamed" /> parameter.
            </exception>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.RWLock">
      <summary>
            Users of this <see cref="T:Castle.DynamicProxy.ModuleScope" /> should use this lock when accessing the cache.
            </summary>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.StrongNamedModule">
      <summary>
            Gets the strong-named module generated by this scope, or <see langword="null" /> if none has yet been generated.
            </summary>
      <value>The strong-named module generated by this scope, or <see langword="null" /> if none has yet been generated.</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.StrongNamedModuleName">
      <summary>
            Gets the file name of the strongly named module generated by this scope.
            </summary>
      <value>The file name of the strongly named module generated by this scope.</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.StrongNamedModuleDirectory">
      <summary>
            Gets the directory where the strongly named module generated by this scope will be saved, or <see langword="null" /> if the current directory
            is used.
            </summary>
      <value>The directory where the strongly named module generated by this scope will be saved when <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly" /> is called
            (if this scope was created to save modules).</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.WeakNamedModule">
      <summary>
            Gets the weak-named module generated by this scope, or <see langword="null" /> if none has yet been generated.
            </summary>
      <value>The weak-named module generated by this scope, or <see langword="null" /> if none has yet been generated.</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.WeakNamedModuleName">
      <summary>
            Gets the file name of the weakly named module generated by this scope.
            </summary>
      <value>The file name of the weakly named module generated by this scope.</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.WeakNamedModuleDirectory">
      <summary>
            Gets the directory where the weakly named module generated by this scope will be saved, or <see langword="null" /> if the current directory
            is used.
            </summary>
      <value>The directory where the weakly named module generated by this scope will be saved when <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly" /> is called
            (if this scope was created to save modules).</value>
    </member>
    <member name="T:Castle.DynamicProxy.PersistentProxyBuilder">
      <summary>
            ProxyBuilder that persists the generated type.
            </summary>
      <remarks>
            The saved assembly contains just the last generated type.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.PersistentProxyBuilder.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.PersistentProxyBuilder" /> class.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerationOptions.#ctor(Castle.DynamicProxy.IProxyGenerationHook)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerationOptions" /> class.
            </summary>
      <param name="hook">The hook.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerationOptions.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerationOptions" /> class.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.#ctor(Castle.DynamicProxy.IProxyBuilder)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerator" /> class.
            </summary>
      <param name="builder">The builder.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerator" /> class.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.Core.Interceptor.IInterceptor[])">
      <summary>
            Creates the class proxy.
            </summary>
      <param name="targetType">Type of the target.</param>
      <param name="interfaces">The interfaces.</param>
      <param name="interceptors">The interceptors.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.Core.Interceptor.IInterceptor[],System.Object[])">
      <summary>
            Creates the class proxy.
            </summary>
      <param name="targetType">Type of the target.</param>
      <param name="interceptors">The interceptors.</param>
      <param name="constructorArgs">The constructor args.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,Castle.Core.Interceptor.IInterceptor[])">
      <summary>
      </summary>
      <param name="targetType">
      </param>
      <param name="options">
      </param>
      <param name="interceptors">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.Core.Interceptor.IInterceptor[])">
      <summary>
            Creates the class proxy.
            </summary>
      <param name="targetType">Type of the target.</param>
      <param name="interfaces">The interfaces.</param>
      <param name="options">The options.</param>
      <param name="constructorArgs">The constructor args.</param>
      <param name="interceptors">The interceptors.</param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.DynamicProxy.ProxyGenerator.ProxyBuilder">
      <summary>
            Gets the proxy builder instance.
            </summary>
      <value>The proxy builder.</value>
    </member>
    <member name="M:Castle.DynamicProxy.RemotableInvocation.Proceed">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.DynamicProxy.RemotableInvocation.Method">
      <summary>
      </summary>
    </member>
    <member name="P:Castle.DynamicProxy.RemotableInvocation.MethodInvocationTarget">
      <summary>
            For interface proxies, this will point to the
            <see cref="T:System.Reflection.MethodInfo" /> on the target class
            </summary>
    </member>
    <member name="T:Castle.Core.LifestyleAttribute">
      <summary>
            Base for Attributes that want to express lifestyle
            chosen by the component.
            </summary>
    </member>
    <member name="M:Castle.Core.LifestyleAttribute.#ctor(Castle.Core.LifestyleType)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.LifestyleAttribute" /> class.
            </summary>
      <param name="type">The type.</param>
    </member>
    <member name="P:Castle.Core.LifestyleAttribute.Lifestyle">
      <summary>
            Gets or sets the lifestyle.
            </summary>
      <value>The lifestyle.</value>
    </member>
    <member name="T:Castle.Core.CastleComponentAttribute">
      <summary>
            This attribute is usefull only when you want to register all components
            on an assembly as a batch process. 
            By doing so, the batch register will look 
            for this attribute to distinguish components from other classes.
            </summary>
    </member>
    <member name="M:Castle.Core.CastleComponentAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.CastleComponentAttribute" /> class.
            </summary>
      <param name="key">The key.</param>
    </member>
    <member name="M:Castle.Core.CastleComponentAttribute.#ctor(System.String,System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.CastleComponentAttribute" /> class.
            </summary>
      <param name="key">The key.</param>
      <param name="service">The service.</param>
    </member>
    <member name="M:Castle.Core.CastleComponentAttribute.#ctor(System.String,System.Type,Castle.Core.LifestyleType)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.CastleComponentAttribute" /> class.
            </summary>
      <param name="key">The key.</param>
      <param name="service">The service.</param>
      <param name="lifestyle">The lifestyle.</param>
    </member>
    <member name="P:Castle.Core.CastleComponentAttribute.Service">
      <summary>
            Gets the service.
            </summary>
      <value>The service.</value>
    </member>
    <member name="P:Castle.Core.CastleComponentAttribute.Key">
      <summary>
            Gets the key.
            </summary>
      <value>The key.</value>
    </member>
    <member name="T:Castle.Core.ComponentActivatorAttribute">
      <summary>
            Associates a custom component with a component
            </summary>
    </member>
    <member name="M:Castle.Core.ComponentActivatorAttribute.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ComponentActivatorAttribute" /> class.
            </summary>
      <param name="componentActivatorType">Type of the component activator.</param>
    </member>
    <member name="P:Castle.Core.ComponentActivatorAttribute.ComponentActivatorType">
      <summary>
            Gets the type of the component activator.
            </summary>
      <value>The type of the component activator.</value>
    </member>
    <member name="T:Castle.Core.ComponentProxyBehaviorAttribute">
      <summary>
            Specifies the proxying behavior for a component.
            </summary>
    </member>
    <member name="M:Castle.Core.ComponentProxyBehaviorAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ComponentProxyBehaviorAttribute" /> class.
            </summary>
    </member>
    <member name="P:Castle.Core.ComponentProxyBehaviorAttribute.UseMarshalByRefProxy">
      <summary>
            Gets or sets a value indicating whether the generated 
            interface proxy should inherit from <see cref="T:System.MarshalByRefObject" />.
            </summary>
    </member>
    <member name="P:Castle.Core.ComponentProxyBehaviorAttribute.UseSingleInterfaceProxy">
      <summary>
            Determines if the component requires a single interface proxy.
            </summary>
      <value>
        <c>true</c> if the component requires a single interface proxy.</value>
    </member>
    <member name="P:Castle.Core.ComponentProxyBehaviorAttribute.AdditionalInterfaces">
      <summary>
             Gets or sets the additional interfaces used during proxy generation.
            </summary>
    </member>
    <member name="T:Castle.Core.DoNotWireAttribute">
      <summary>
            Marks as property to be skipped and not be wired
            by the IoC container
            </summary>
    </member>
    <member name="T:Castle.Core.InterceptorAttribute">
      <summary>
            Used to declare that a component wants interceptors acting on it.
            </summary>
    </member>
    <member name="M:Castle.Core.InterceptorAttribute.#ctor(System.String)">
      <summary>
            Constructs the InterceptorAttribute pointing to
            a key to a interceptor
            </summary>
      <param name="componentKey">
      </param>
    </member>
    <member name="M:Castle.Core.InterceptorAttribute.#ctor(System.Type)">
      <summary>
            Constructs the InterceptorAttribute pointing to
            a service
            </summary>
      <param name="interceptorType">
      </param>
    </member>
    <member name="T:Castle.Core.SingletonAttribute">
      <summary>
            Indicates that the target components wants a
            singleton lifestyle.
            </summary>
    </member>
    <member name="M:Castle.Core.SingletonAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.SingletonAttribute" /> class.
            </summary>
    </member>
    <member name="T:Castle.Core.TransientAttribute">
      <summary>
            Indicates that the target components wants a
            transient lifestyle.
            </summary>
    </member>
    <member name="M:Castle.Core.TransientAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.TransientAttribute" /> class.
            </summary>
    </member>
    <member name="T:Castle.Core.PerThreadAttribute">
      <summary>
            Indicates that the target components wants a
            per thread lifestyle.
            </summary>
    </member>
    <member name="M:Castle.Core.PerThreadAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.PerThreadAttribute" /> class.
            </summary>
    </member>
    <member name="T:Castle.Core.PerWebRequestAttribute">
      <summary>
            Indicates that the target components wants a
            per web request lifestyle.
            </summary>
    </member>
    <member name="T:Castle.Core.PooledAttribute">
      <summary>
            Indicates that the target components wants a
            pooled lifestyle.
            </summary>
    </member>
    <member name="M:Castle.Core.PooledAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.PooledAttribute" /> class
            using the default initial pool size (5) and the max pool size (15).
            </summary>
    </member>
    <member name="M:Castle.Core.PooledAttribute.#ctor(System.Int32,System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.PooledAttribute" /> class.
            </summary>
      <param name="initialPoolSize">Initial size of the pool.</param>
      <param name="maxPoolSize">Max pool size.</param>
    </member>
    <member name="P:Castle.Core.PooledAttribute.InitialPoolSize">
      <summary>
            Gets the initial size of the pool.
            </summary>
      <value>The initial size of the pool.</value>
    </member>
    <member name="P:Castle.Core.PooledAttribute.MaxPoolSize">
      <summary>
            Gets the maximum pool size.
            </summary>
      <value>The size of the max pool.</value>
    </member>
    <member name="T:Castle.Core.CustomLifestyleAttribute">
      <summary>
            Indicates that the target components wants a
            custom lifestyle.
            </summary>
    </member>
    <member name="M:Castle.Core.CustomLifestyleAttribute.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.CustomLifestyleAttribute" /> class.
            </summary>
      <param name="lifestyleHandler">The lifestyle handler.</param>
    </member>
    <member name="P:Castle.Core.CustomLifestyleAttribute.LifestyleHandlerType">
      <summary>
            Gets the type of the lifestyle handler.
            </summary>
      <value>The type of the lifestyle handler.</value>
    </member>
    <member name="T:Castle.Core.Interceptor.IInterceptor">
      <summary>
            New interface that is going to be used by DynamicProxy 2
            </summary>
    </member>
    <member name="T:Castle.Core.Interceptor.IInvocation">
      <summary>
            New interface that is going to be used by DynamicProxy 2
            </summary>
    </member>
    <member name="M:Castle.Core.Interceptor.IInvocation.GetConcreteMethod">
      <summary>
            Returns the concrete instantiation of <see cref="P:Castle.Core.Interceptor.IInvocation.Method" />, with any generic parameters bound to real types.
            </summary>
      <returns>The concrete instantiation of <see cref="P:Castle.Core.Interceptor.IInvocation.Method" />, or <see cref="P:Castle.Core.Interceptor.IInvocation.Method" /> if not a generic method.</returns>
      <remarks>Can be slower than calling <see cref="P:Castle.Core.Interceptor.IInvocation.Method" />.</remarks>
    </member>
    <member name="M:Castle.Core.Interceptor.IInvocation.GetConcreteMethodInvocationTarget">
      <summary>
            Returns the concrete instantiation of <see cref="P:Castle.Core.Interceptor.IInvocation.MethodInvocationTarget" />, with any generic parameters bound to real types.
            </summary>
      <returns>The concrete instantiation of <see cref="P:Castle.Core.Interceptor.IInvocation.MethodInvocationTarget" />, or <see cref="P:Castle.Core.Interceptor.IInvocation.MethodInvocationTarget" /> if not a generic method.</returns>
      <remarks>Can be slower than calling <see cref="P:Castle.Core.Interceptor.IInvocation.MethodInvocationTarget" />.</remarks>
    </member>
    <member name="M:Castle.Core.Interceptor.IInvocation.Proceed">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.Core.Interceptor.IInvocation.GenericArguments">
      <summary>
            The generic arguments of the method, or null if not a generic method.
            </summary>
    </member>
    <member name="P:Castle.Core.Interceptor.IInvocation.Method">
      <summary>
      </summary>
    </member>
    <member name="P:Castle.Core.Interceptor.IInvocation.MethodInvocationTarget">
      <summary>
            For interface proxies, this will point to the
            <see cref="T:System.Reflection.MethodInfo" /> on the target class
            </summary>
    </member>
    <member name="T:Castle.Core.Interceptor.IOnBehalfAware">
      <summary>
            Interceptors might implement this to receive the
            ComponentModel on behalf of the component where the
            interceptor is acting.
            </summary>
    </member>
    <member name="M:Castle.Core.Interceptor.IProxyTargetAccessor.DynProxyGetTarget">
      <summary>
            Get the proxy target (note that null is a valid target!)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Interceptor.IProxyTargetAccessor.GetInterceptors">
      <summary>
            Gets the interceptors for the proxy
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.IVertex">
      <summary>
            Abstract representation of a vertex.
            </summary>
    </member>
    <member name="P:Castle.Core.GraphNode.Dependers">
      <summary>
            The nodes that dependes on this node
            </summary>
    </member>
    <member name="P:Castle.Core.GraphNode.Dependents">
      <summary>
            The nodes that this node depends
            </summary>
    </member>
    <member name="F:Castle.Core.Internal.VertexColor.White">
      <summary>
            The node has not been visited yet
            </summary>
    </member>
    <member name="F:Castle.Core.Internal.VertexColor.Gray">
      <summary>
            This node is in the process of being visited
            </summary>
    </member>
    <member name="F:Castle.Core.Internal.VertexColor.Black">
      <summary>
            This now was visited
            </summary>
    </member>
    <member name="T:Castle.Core.Internal.ColorsSet">
      <summary>
            Represents a collection of objects
            which are guaranted to be unique 
            and holds a color for them
            </summary>
    </member>
    <member name="T:Castle.Core.Internal.TimestampSet">
      <summary>
            Holds a timestamp (integer) 
            for a given item
            </summary>
    </member>
    <member name="M:Castle.Core.Internal.LinkedList.GetNode(System.Int32)">
      <summary>
            Returns the node at the specified index.
            </summary>
      <param name="index">The lookup index.</param>
      <returns>The node at the specified index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
            If the specified <paramref name="index" /> is greater than the
            number of objects within the list.
            </exception>
    </member>
    <member name="M:Castle.Core.Internal.LinkedList.ValidateIndex(System.Int32)">
      <summary>
            Validates the specified index.
            </summary>
      <param name="index">The lookup index.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
            If the index is invalid.
            </exception>
    </member>
    <member name="T:Castle.Core.IInitializable">
      <summary>
            Lifecycle interface. If implemented by a component,
            the method Initialized will be invoked by the container
            before making the component available to the external world.
            </summary>
    </member>
    <member name="M:Castle.Core.IInitializable.Initialize">
      <summary>
            Implementors should perform any initialization logic.
            </summary>
    </member>
    <member name="T:Castle.Core.IRecyclable">
      <summary>
            Only called for components that 
            belongs to a pool when the component
            comes back to the pool.
            </summary>
    </member>
    <member name="M:Castle.Core.IRecyclable.Recycle">
      <summary>
            Implementors should perform any 
            initialization/clean up.
            </summary>
    </member>
    <member name="T:Castle.Core.IStartable">
      <summary>
            Interface for components that wish to be started by the container
            </summary>
    </member>
    <member name="M:Castle.Core.IStartable.Start">
      <summary>
            Starts this instance.
            </summary>
    </member>
    <member name="M:Castle.Core.IStartable.Stop">
      <summary>
            Stops this instance.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.ILoggerFactory">
      <summary>
            Manages the instantiation of <see cref="T:Castle.Core.Logging.ILogger" />s.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.Type)">
      <summary>
            Creates a new logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.String)">
      <summary>
            Creates a new logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new logger.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.IExtendedLoggerFactory">
      <summary>
            Provides a factory that can produce either <see cref="T:Castle.Core.Logging.ILogger" /> or
            <see cref="T:Castle.Core.Logging.IExtendedLogger" /> classes.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.Type)">
      <summary>
            Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.String)">
      <summary>
            Creates a new extended logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new extended logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.Factories.AbstractExtendedLoggerFactory.Create(System.Type)">
      <summary>
            Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.Factories.AbstractExtendedLoggerFactory.Create(System.String)">
      <summary>
            Creates a new extended logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.Factories.AbstractExtendedLoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.Factories.AbstractExtendedLoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new extended logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.Factories.AbstractExtendedLoggerFactory.GetConfigFile(System.String)">
      <summary>
            Gets the configuration file.
            </summary>
      <param name="filename">i.e. log4net.config</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Logging.AbstractLoggerFactory.GetConfigFile(System.String)">
      <summary>
            Gets the configuration file.
            </summary>
      <param name="filename">i.e. log4net.config</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.Logging.ConsoleFactory">
      <summary>
            Summary description for ConsoleFactory.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.NullLogFactory">
      <summary>
            NullLogFactory used when logging is turned off.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.NullLogFactory.Create(System.String)">
      <summary>
            Creates an instance of ILogger with the specified name.
            </summary>
      <param name="name">Name.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Logging.NullLogFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates an instance of ILogger with the specified name and LoggerLevel.
            </summary>
      <param name="name">Name.</param>
      <param name="level">Level.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.Logging.StreamLoggerFactory">
      <summary>
            Creates <see cref="T:Castle.Core.Logging.StreamLogger" /> outputing 
            to files. The name of the file is derived from the log name
            plus the 'log' extension.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.ILogger">
      <summary>
            Manages logging.
            </summary>
      <remarks>
            This is a facade for the different logging subsystems.
            It offers a simplified interface that follows IOC patterns
            and a simplified priority/level/severity abstraction. 
            </remarks>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Debug(System.String)">
      <summary>
            Logs a debug message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Debug(System.String,System.Exception)">
      <summary>
            Logs a debug message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Debug(System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Info(System.String)">
      <summary>
            Logs an info message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Info(System.String,System.Exception)">
      <summary>
            Logs an info message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Info(System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Warn(System.String)">
      <summary>
            Logs a warn message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Warn(System.String,System.Exception)">
      <summary>
            Logs a warn message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Warn(System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Error(System.String)">
      <summary>
            Logs an error message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Error(System.String,System.Exception)">
      <summary>
            Logs an error message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Error(System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Fatal(System.String)">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Fatal(System.String,System.Exception)">
      <summary>
            Logs a fatal message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Fatal(System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalError(System.String)">
      <summary>
            Logs a fatal error message.
            </summary>
      <param name="message">The Message</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalError(System.String,System.Exception)">
      <summary>
            Logs a fatal error message.
            </summary>
      <param name="message">The Message</param>
      <param name="exception">The Exception</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalError(System.String,System.Object[])">
      <summary>
            Logs a fatal error message.
            </summary>
      <param name="format">Message format</param>
      <param name="args">Array of objects to write using format</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.CreateChildLogger(System.String)">
      <summary>
            Create a new child logger.
            The name of the child logger is [current-loggers-name].[passed-in-name]
            </summary>
      <param name="name">The Subname of this logger.</param>
      <returns>The New ILogger instance.</returns>
      <exception cref="T:System.ArgumentException">If the name has an empty element name.</exception>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsDebugEnabled">
      <summary>
            Determines if messages of priority "debug" will be logged.
            </summary>
      <value>True if "debug" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsInfoEnabled">
      <summary>
            Determines if messages of priority "info" will be logged.
            </summary>
      <value>True if "info" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsWarnEnabled">
      <summary>
            Determines if messages of priority "warn" will be logged.
            </summary>
      <value>True if "warn" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsErrorEnabled">
      <summary>
            Determines if messages of priority "error" will be logged.
            </summary>
      <value>True if "error" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsFatalEnabled">
      <summary>
            Determines if messages of priority "fatal" will be logged.
            </summary>
      <value>True if "fatal" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsFatalErrorEnabled">
      <summary>
            Determines if messages of priority "fatalError" will be logged.
            </summary>
      <value>True if "fatalError" messages will be logged.</value>
    </member>
    <member name="T:Castle.Core.Logging.LevelFilteredLogger">
      <summary>
            The Level Filtered Logger class.  This is a base clase which
            provides a LogLevel attribute and reroutes all functions into
            one Log method.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.#ctor">
      <summary>
            Creates a new <c>LevelFilteredLogger</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InitializeLifetimeService">
      <summary>
            Keep the instance alive in a remoting scenario
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Debug(System.String)">
      <summary>
            Logs a debug message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Debug(System.String,System.Exception)">
      <summary>
            Logs a debug message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Debug(System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="format">Message format</param>
      <param name="args">Array of objects to write using format</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Info(System.String)">
      <summary>
            Logs an info message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Info(System.String,System.Exception)">
      <summary>
            Logs an info message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Info(System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="format">Message format</param>
      <param name="args">Array of objects to write using format</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Warn(System.String)">
      <summary>
            Logs a warn message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Warn(System.String,System.Exception)">
      <summary>
            Logs a warn message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Warn(System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="format">Message format</param>
      <param name="args">Array of objects to write using format</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Error(System.String)">
      <summary>
            Logs an error message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Error(System.String,System.Exception)">
      <summary>
            Logs an error message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Error(System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="format">Message format</param>
      <param name="args">Array of objects to write using format</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Fatal(System.String)">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Fatal(System.String,System.Exception)">
      <summary>
            Logs a fatal message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Fatal(System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="format">Message format</param>
      <param name="args">Array of objects to write using format</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalError(System.String)">
      <summary>
            Logs a fatal error message.
            </summary>
      <param name="message">The Message</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalError(System.String,System.Exception)">
      <summary>
            Logs a fatal error message.
            </summary>
      <param name="message">The Message</param>
      <param name="exception">The Exception</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalError(System.String,System.Object[])">
      <summary>
            Logs a fatal error message.
            </summary>
      <param name="format">Message format</param>
      <param name="args">Array of objects to write using format</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Log(Castle.Core.Logging.LoggerLevel,System.String,System.String,System.Exception)">
      <summary>
            Implementors output the log content by implementing this method only.
            Note that exception can be null
            </summary>
      <param name="level">
      </param>
      <param name="name">
      </param>
      <param name="message">
      </param>
      <param name="exception">
      </param>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.Level">
      <value>
            The <c>LoggerLevel</c> that this logger
            will be using. Defaults to <c>LoggerLevel.Off</c></value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.Name">
      <value>
            The name that this logger will be using. 
            Defaults to <c>String.Empty</c></value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsDebugEnabled">
      <summary>
            Determines if messages of priority "debug" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Debug" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsInfoEnabled">
      <summary>
            Determines if messages of priority "info" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Info" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsWarnEnabled">
      <summary>
            Determines if messages of priority "warn" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Warn" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsErrorEnabled">
      <summary>
            Determines if messages of priority "error" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Error" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsFatalEnabled">
      <summary>
            Determines if messages of priority "fatal" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Fatal" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsFatalErrorEnabled">
      <summary>
            Determines if messages of priority "fatal" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Fatal" /> bit</value>
    </member>
    <member name="T:Castle.Core.Logging.ConsoleLogger">
      <summary>
            The Logger sending everything to the standard output streams.
            This is mainly for the cases when you have a utility that
            does not have a logger to supply.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor">
      <summary>
            Creates a new ConsoleLogger with the <c>Level</c>
            set to <c>LoggerLevel.Debug</c> and the <c>Name</c>
            set to <c>String.Empty</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor(Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new ConsoleLogger with the <c>Name</c>
            set to <c>String.Empty</c>.
            </summary>
      <param name="logLevel">The logs Level.</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor(System.String)">
      <summary>
            Creates a new ConsoleLogger with the <c>Level</c>
            set to <c>LoggerLevel.Debug</c>.
            </summary>
      <param name="name">The logs Name.</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new ConsoleLogger.
            </summary>
      <param name="name">The logs Name.</param>
      <param name="logLevel">The logs Level.</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.Log(Castle.Core.Logging.LoggerLevel,System.String,System.String,System.Exception)">
      <summary>
            A Common method to log.
            </summary>
      <param name="level">The level of logging</param>
      <param name="name">The name of the logger</param>
      <param name="message">The Message</param>
      <param name="exception">The Exception</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.CreateChildLogger(System.String)">
      <summary>
            Returns a new <c>ConsoleLogger</c> with the name
            added after this loggers name, with a dot in between.
            </summary>
      <param name="newName">The added hierarchical name.</param>
      <returns>A new <c>ConsoleLogger</c>.</returns>
    </member>
    <member name="T:Castle.Core.Logging.DiagnosticsLogger">
      <summary>
            The Logger using standart Diagnostics namespace.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.DiagnosticsLogger.#ctor(System.String)">
      <summary>
            Creates a logger based on <see cref="T:System.Diagnostics.EventLog" />.
            </summary>
      <param name="logName">
        <see cref="P:System.Diagnostics.EventLog.Log" />
      </param>
    </member>
    <member name="M:Castle.Core.Logging.DiagnosticsLogger.#ctor(System.String,System.String)">
      <summary>
            Creates a logger based on <see cref="T:System.Diagnostics.EventLog" />.
            </summary>
      <param name="logName">
        <see cref="P:System.Diagnostics.EventLog.Log" />
      </param>
      <param name="source">
        <see cref="P:System.Diagnostics.EventLog.Source" />
      </param>
    </member>
    <member name="M:Castle.Core.Logging.DiagnosticsLogger.#ctor(System.String,System.String,System.String)">
      <summary>
            Creates a logger based on <see cref="T:System.Diagnostics.EventLog" />.
            </summary>
      <param name="logName">
        <see cref="P:System.Diagnostics.EventLog.Log" />
      </param>
      <param name="machineName">
        <see cref="P:System.Diagnostics.EventLog.MachineName" />
      </param>
      <param name="source">
        <see cref="P:System.Diagnostics.EventLog.Source" />
      </param>
    </member>
    <member name="T:Castle.Core.Logging.IExtendedLogger">
      <summary>
            Provides an interface that supports <see cref="T:Castle.Core.Logging.ILogger" /> and
            allows the storage and retrieval of Contexts. These are supported in
            both log4net and NLog.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.IExtendedLogger.GlobalProperties">
      <summary>
            Exposes the Global Context of the extended logger. 
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.IExtendedLogger.ThreadProperties">
      <summary>
            Exposes the Thread Context of the extended logger.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.IExtendedLogger.ThreadStacks">
      <summary>
            Exposes the Thread Stack of the extended logger.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.NullLogger">
      <summary>
            The Null Logger class.  This is useful for implementations where you need
            to provide a logger to a utility class, but do not want any output from it.
            It also helps when you have a utility that does not have a logger to supply.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.#ctor">
      <summary>
            Creates a new <c>NullLogger</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Debug(System.String)">
      <summary>
            No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Debug(System.String,System.Exception)">
      <summary>
            No-op. 
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Debug(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.Exception,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Info(System.String)">
      <summary>
            No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Info(System.String,System.Exception)">
      <summary>
            No-op. 
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Info(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.Exception,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Warn(System.String)">
      <summary>
            No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Warn(System.String,System.Exception)">
      <summary>
            No-op. 
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Warn(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.Exception,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Error(System.String)">
      <summary>
            No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Error(System.String,System.Exception)">
      <summary>
            No-op. 
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Error(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.Exception,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Fatal(System.String)">
      <summary>
            No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Fatal(System.String,System.Exception)">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Fatal(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.Exception,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalError(System.String)">
      <summary>
            No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalError(System.String,System.Exception)">
      <summary>
            No-op.
            </summary>
      <param name="message">Ignored</param>
      <param name="exception">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalError(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.CreateChildLogger(System.String)">
      <summary>
            Returns this <c>NullLogger</c>.
            </summary>
      <param name="name">Ignored</param>
      <returns>This ILogger instance.</returns>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsDebugEnabled">
      <summary>
            No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsInfoEnabled">
      <summary>
            No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsWarnEnabled">
      <summary>
            No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsErrorEnabled">
      <summary>
            No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsFatalEnabled">
      <summary>
            No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsFatalErrorEnabled">
      <summary>
            No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.GlobalProperties">
      <summary>
            Returns empty context properties.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.ThreadProperties">
      <summary>
            Returns empty context properties.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.ThreadStacks">
      <summary>
            Returns empty context stacks.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.IContextProperties">
      <summary>
            Interface for Context Properties implementations
            </summary>
      <remarks>
        <para>
            This interface defines a basic property get set accessor.
            </para>
        <para>
            Based on the ContextPropertiesBase of log4net, by Nicko Cadell.
            </para>
      </remarks>
    </member>
    <member name="P:Castle.Core.Logging.IContextProperties.Item(System.String)">
      <summary>
            Gets or sets the value of a property
            </summary>
      <value>
            The value for the property with the specified key
            </value>
      <remarks>
        <para>
            Gets or sets the value of a property
            </para>
      </remarks>
    </member>
    <member name="T:Castle.Core.Logging.StreamLogger">
      <summary>
            The Stream Logger class.  This class can stream log information
            to any stream, it is suitable for storing a log file to disk,
            or to a <c>MemoryStream</c> for testing your components.
            </summary>
      <remarks>
            This logger is not thread safe.
            </remarks>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.Stream)">
      <summary>
            Creates a new <c>StreamLogger</c> with default encoding 
            and buffer size. Initial Level is set to Debug.
            </summary>
      <param name="name">
            The name of the log.
            </param>
      <param name="stream">
            The stream that will be used for logging,
            seeking while the logger is alive 
            </param>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.Stream,System.Text.Encoding)">
      <summary>
            Creates a new <c>StreamLogger</c> with default buffer size.
            Initial Level is set to Debug.
            </summary>
      <param name="name">
            The name of the log.
            </param>
      <param name="stream">
            The stream that will be used for logging,
            seeking while the logger is alive 
            </param>
      <param name="encoding">
            The encoding that will be used for this stream.
            <see cref="T:System.IO.StreamWriter" /></param>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.Stream,System.Text.Encoding,System.Int32)">
      <summary>
            Creates a new <c>StreamLogger</c>. 
            Initial Level is set to Debug.
            </summary>
      <param name="name">
            The name of the log.
            </param>
      <param name="stream">
            The stream that will be used for logging,
            seeking while the logger is alive 
            </param>
      <param name="encoding">
            The encoding that will be used for this stream.
            <see cref="T:System.IO.StreamWriter" /></param>
      <param name="bufferSize">
            The buffer size that will be used for this stream.
            <see cref="T:System.IO.StreamWriter" /></param>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.StreamWriter)">
      <summary>
            Creates a new <c>StreamLogger</c> with 
            Debug as default Level.
            </summary>
      <param name="name">The name of the log.</param>
      <param name="writer">The <c>StreamWriter</c> the log will write to.</param>
    </member>
    <member name="T:Castle.Core.Logging.WebLogger">
      <summary>
            The WebLogger sends everything to the HttpContext.Trace 
            </summary>
      <remarks>
            Trace must be enabled on the Asp.Net configuration file (web.config or machine.config)
            </remarks>
    </member>
    <member name="M:Castle.Core.Logging.WebLogger.#ctor">
      <summary>
            Creates a new WebLogger with the priority set to DEBUG.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.WebLogger.#ctor(Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new WebLogger.
            </summary>
      <param name="logLevel">The Log level typecode.</param>
    </member>
    <member name="M:Castle.Core.Logging.WebLogger.#ctor(System.String)">
      <summary>
            Creates a new WebLogger.
            </summary>
      <param name="name">The Log name.</param>
    </member>
    <member name="M:Castle.Core.Logging.WebLogger.#ctor(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new WebLogger.
            </summary>
      <param name="name">The Log name.</param>
      <param name="logLevel">The Log level typecode.</param>
    </member>
    <member name="M:Castle.Core.Logging.WebLogger.Log(Castle.Core.Logging.LoggerLevel,System.String,System.String,System.Exception)">
      <summary>
            A Common method to log.
            </summary>
      <param name="level">The level of logging</param>
      <param name="name">The Log name.</param>
      <param name="message">The Message</param>
      <param name="exception">The Exception</param>
    </member>
    <member name="M:Castle.Core.Logging.WebLogger.CreateChildLogger(System.String)">
      <summary>
            Just returns this logger (<c>WebLogger</c> is not hierarchical).
            </summary>
      <param name="newName">Ignored</param>
      <returns>This ILogger instance.</returns>
    </member>
    <member name="T:Castle.Core.Logging.LoggerLevel">
      <summary>
            Supporting Logger levels.
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Off">
      <summary>
            Logging will be off
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Fatal">
      <summary>
            Fatal logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Error">
      <summary>
            Error logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Warn">
      <summary>
            Warn logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Info">
      <summary>
            Info logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Debug">
      <summary>
            Debug logging level
            </summary>
    </member>
    <member name="T:Castle.Core.Configuration.IConfiguration">
      <summary>
            Summary description for IConfiguration.
            </summary>
      <summary>
        <see cref="T:Castle.Core.Configuration.IConfiguration" /> is a interface encapsulating a configuration node
            used to retrieve configuration values.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.IConfiguration.GetValue(System.Type,System.Object)">
      <summary>
            Gets the value of the node and converts it 
            into specified <see cref="T:System.Type" />.
            </summary>
      <param name="type">The <see cref="T:System.Type" /></param>
      <param name="defaultValue">
            The Default value returned if the convertion fails.
            </param>
      <returns>The Value converted into the specified type.</returns>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Name">
      <summary>
            Gets the name of the node.
            </summary>
      <value>
            The Name of the node.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Value">
      <summary>
            Gets the value of the node.
            </summary>
      <value>
            The Value of the node.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Children">
      <summary>
            Gets an <see cref="T:Castle.Core.Configuration.ConfigurationCollection" /> of <see cref="T:Castle.Core.Configuration.IConfiguration" />
            elements containing all node children.
            </summary>
      <value>The Collection of child nodes.</value>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Attributes">
      <summary>
            Gets an <see cref="T:System.Collections.IDictionary" /> of the configuration attributes.
            </summary>
    </member>
    <member name="T:Castle.Core.Configuration.AbstractConfiguration">
      <summary>
            This is an abstract <see cref="T:Castle.Core.Configuration.IConfiguration" /> implementation
            that deals with methods that can be abstracted away
            from underlying implementations.
            </summary>
      <remarks>
        <para>
          <b>AbstractConfiguration</b> makes easier to implementers 
            to create a new version of <see cref="T:Castle.Core.Configuration.IConfiguration" /></para>
      </remarks>
    </member>
    <member name="M:Castle.Core.Configuration.AbstractConfiguration.GetValue(System.Type,System.Object)">
      <summary>
            Gets the value of the node and converts it
            into specified <see cref="T:System.Type" />.
            </summary>
      <param name="type">The <see cref="T:System.Type" /></param>
      <param name="defaultValue">
            The Default value returned if the convertion fails.
            </param>
      <returns>The Value converted into the specified type.</returns>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Name">
      <summary>
            Gets the name of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </summary>
      <value>
            The Name of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Value">
      <summary>
            Gets the value of <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </summary>
      <value>
            The Value of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Children">
      <summary>
            Gets all child nodes.
            </summary>
      <value>The <see cref="T:Castle.Core.Configuration.ConfigurationCollection" /> of child nodes.</value>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Attributes">
      <summary>
            Gets node attributes.
            </summary>
      <value>
            All attributes of the node.
            </value>
    </member>
    <member name="T:Castle.Core.Configuration.ConfigurationCollection">
      <summary>
            A collection of <see cref="T:Castle.Core.Configuration.IConfiguration" /> objects.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.#ctor">
      <summary>
            Creates a new instance of <c>ConfigurationCollection</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.#ctor(Castle.Core.Configuration.ConfigurationCollection)">
      <summary>
            Creates a new instance of <c>ConfigurationCollection</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.#ctor(Castle.Core.Configuration.IConfiguration[])">
      <summary>
            Creates a new instance of <c>ConfigurationCollection</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.Add(Castle.Core.Configuration.IConfiguration)">
      <summary>
            Adds an <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </summary>
      <param name="value">The <see cref="T:Castle.Core.Configuration.IConfiguration" /> to add.</param>
      <returns>
            The index at which the new element was inserted.
            </returns>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.AddRange(Castle.Core.Configuration.IConfiguration[])">
      <summary>
            Adds an array of <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </summary>
      <param name="value">The Array of <see cref="T:Castle.Core.Configuration.IConfiguration" /> to add.</param>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.AddRange(Castle.Core.Configuration.ConfigurationCollection)">
      <summary>
            Adds a <see cref="T:Castle.Core.Configuration.ConfigurationCollection" />.
            </summary>
      <param name="value">The <see cref="T:Castle.Core.Configuration.ConfigurationCollection" /> to add.</param>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.CopyTo(Castle.Core.Configuration.IConfiguration[],System.Int32)">
      <summary>
            Copies the elements to a one-dimensional <see cref="T:System.Array" /> instance at the specified index.
            </summary>
      <param name="array">
            The one-dimensional <see cref="T:System.Array" /> must have zero-based indexing.
            </param>
      <param name="index">The zero-based index in array at which copying begins.</param>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.Contains(Castle.Core.Configuration.IConfiguration)">
      <summary>
            Gets a value indicating whether the <see cref="T:Castle.Core.Configuration.IConfiguration" /> contains
            in the collection.
            </summary>
      <param name="value">The <see cref="T:Castle.Core.Configuration.IConfiguration" /> to locate.</param>
      <returns>
        <see langword="true" /> if the <see cref="T:Castle.Core.Configuration.IConfiguration" /> is contained in the collection; 
            otherwise, <see langword="false" />.
            </returns>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.Remove(Castle.Core.Configuration.IConfiguration)">
      <summary>
            Removes a specific <see cref="T:Castle.Core.Configuration.IConfiguration" /> from the 
            collection.   
            </summary>
      <param name="value">The <see cref="T:Castle.Core.Configuration.IConfiguration" /> to remove from the collection.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> is not found in the collection.
            </exception>
    </member>
    <member name="P:Castle.Core.Configuration.ConfigurationCollection.Item(System.Int32)">
      <summary>
            Represents the entry at the specified index of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </summary>
      <param name="index">
            The zero-based index of the entry to locate in the collection.
            </param>
      <value>
            The entry at the specified index of the collection.
            </value>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is outside the valid range of indexes for the collection.
            </exception>
    </member>
    <member name="T:Castle.Core.Configuration.MutableConfiguration">
      <summary>
            Summary description for MutableConfiguration.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.MutableConfiguration.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.Configuration.MutableConfiguration" /> class.
            </summary>
      <param name="name">The name.</param>
    </member>
    <member name="T:Castle.Core.LifestyleType">
      <summary>
            Enumeration used to mark the component's lifestyle.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.Undefined">
      <summary>
            No lifestyle specified.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.Singleton">
      <summary>
            Singleton components are instantiated once, and shared
            between all clients.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.Thread">
      <summary>
            Thread components have a unique instance per thread.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.Transient">
      <summary>
            Transient components are created on demand.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.Pooled">
      <summary>
            Optimization of transient components that keeps
            instance in a pool instead of always creating them.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.Custom">
      <summary>
            Any other logic to create/release components.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.PerWebRequest">
      <summary>
            PerWebRequest components are created once per Http Request
            </summary>
    </member>
    <member name="T:Castle.Core.PropertiesInspectionBehavior">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Core.ComponentModel">
      <summary>
            Represents the collection of information and
            meta information collected about a component.
            </summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.name">
      <summary>Name (key) of the component</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.service">
      <summary>Service exposed</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.implementation">
      <summary>Implementation for the service</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.extended">
      <summary>Extended properties</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.lifestyleType">
      <summary>Lifestyle for the component</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.customLifestyle">
      <summary>Custom lifestyle, if any</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.customComponentActivator">
      <summary>Custom activator, if any</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.dependencies">
      <summary>Dependencies the kernel must resolve</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.constructors">
      <summary>All available constructors</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.properties">
      <summary>All potential properties that can be setted by the kernel</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.lifecycleSteps">
      <summary>Steps of lifecycle</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.parameters">
      <summary>External parameters</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.configuration">
      <summary>Configuration node associated</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.interceptors">
      <summary>Interceptors associated</summary>
    </member>
    <member name="M:Castle.Core.ComponentModel.#ctor(System.String,System.Type,System.Type)">
      <summary>
            Constructs a ComponentModel
            </summary>
    </member>
    <member name="P:Castle.Core.ComponentModel.Name">
      <summary>
            Sets or returns the component key
            </summary>
    </member>
    <member name="P:Castle.Core.ComponentModel.Service">
      <summary>
            Gets or sets the service exposed.
            </summary>
      <value>The service.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.Implementation">
      <summary>
            Gets or sets the component implementation.
            </summary>
      <value>The implementation.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.RequiresGenericArguments">
      <summary>
            Gets or sets a value indicating whether the component requires generic arguments.
            </summary>
      <value>
        <c>true</c> if generic arguments are required; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Castle.Core.ComponentModel.ExtendedProperties">
      <summary>
            Gets or sets the extended properties.
            </summary>
      <value>The extended properties.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.Constructors">
      <summary>
            Gets the constructors candidates.
            </summary>
      <value>The constructors.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.Properties">
      <summary>
            Gets the properties set.
            </summary>
      <value>The properties.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.Configuration">
      <summary>
            Gets or sets the configuration.
            </summary>
      <value>The configuration.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.LifecycleSteps">
      <summary>
            Gets the lifecycle steps.
            </summary>
      <value>The lifecycle steps.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.LifestyleType">
      <summary>
            Gets or sets the lifestyle type.
            </summary>
      <value>The type of the lifestyle.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.InspectionBehavior">
      <summary>
            Gets or sets the strategy for
            inspecting public properties 
            on the components
            </summary>
    </member>
    <member name="P:Castle.Core.ComponentModel.CustomLifestyle">
      <summary>
            Gets or sets the custom lifestyle.
            </summary>
      <value>The custom lifestyle.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.CustomComponentActivator">
      <summary>
            Gets or sets the custom component activator.
            </summary>
      <value>The custom component activator.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.Interceptors">
      <summary>
            Gets the interceptors.
            </summary>
      <value>The interceptors.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.Parameters">
      <summary>
            Gets the parameter collection.
            </summary>
      <value>The parameters.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.Dependencies">
      <summary>
            Dependencies are kept within constructors and
            properties. Others dependencies must be 
            registered here, so the kernel (as a matter 
            of fact the handler) can check them
            </summary>
    </member>
    <member name="T:Castle.Core.ConstructorCandidate">
      <summary>
            Represents a constructor of the component 
            that the container can use to initialize it properly.
            </summary>
    </member>
    <member name="M:Castle.Core.ConstructorCandidate.#ctor(System.Reflection.ConstructorInfo,Castle.Core.DependencyModel[])">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ConstructorCandidate" /> class.
            </summary>
      <param name="constructorInfo">The constructor info.</param>
      <param name="dependencies">The dependencies.</param>
    </member>
    <member name="P:Castle.Core.ConstructorCandidate.Constructor">
      <summary>
            Gets the ConstructorInfo (from reflection).
            </summary>
      <value>The constructor.</value>
    </member>
    <member name="P:Castle.Core.ConstructorCandidate.Dependencies">
      <summary>
            Gets the dependencies this constructor candidate exposes.
            </summary>
      <value>The dependencies.</value>
    </member>
    <member name="T:Castle.Core.ConstructorCandidateCollection">
      <summary>
            Collection of <see cref="T:Castle.Core.ConstructorCandidate" /></summary>
    </member>
    <member name="M:Castle.Core.ConstructorCandidateCollection.Add(Castle.Core.ConstructorCandidate)">
      <summary>
            Adds the specified candidate.
            </summary>
      <param name="candidate">The candidate.</param>
    </member>
    <member name="M:Castle.Core.ConstructorCandidateCollection.Clear">
      <summary>
            Clears this instance.
            </summary>
    </member>
    <member name="P:Castle.Core.ConstructorCandidateCollection.FewerArgumentsCandidate">
      <summary>
            Gets the fewer arguments candidate.
            </summary>
      <value>The fewer arguments candidate.</value>
    </member>
    <member name="T:Castle.Core.DependencyModel">
      <summary>
            Represents a dependency (other component or a 
            fixed value available through external configuration).
            </summary>
    </member>
    <member name="M:Castle.Core.DependencyModel.#ctor(Castle.Core.DependencyType,System.String,System.Type,System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.DependencyModel" /> class.
            </summary>
      <param name="type">The type.</param>
      <param name="dependencyKey">The dependency key.</param>
      <param name="targetType">Type of the target.</param>
      <param name="isOptional">if set to <c>true</c> [is optional].</param>
    </member>
    <member name="M:Castle.Core.DependencyModel.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="M:Castle.Core.DependencyModel.GetHashCode">
      <summary>
            Serves as a hash function for a particular type, suitable
            for use in hashing algorithms and data structures like a hash table.
            </summary>
      <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="M:Castle.Core.DependencyModel.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
      <returns>
        <see langword="true" /> if the specified <see cref="T:System.Object" /> is equal to the
            current <see cref="T:System.Object" />; otherwise, <see langword="false" />.
            </returns>
    </member>
    <member name="P:Castle.Core.DependencyModel.DependencyType">
      <summary>
            Gets or sets the type of the dependency.
            </summary>
      <value>The type of the dependency.</value>
    </member>
    <member name="P:Castle.Core.DependencyModel.DependencyKey">
      <summary>
            Gets or sets the dependency key.
            </summary>
      <value>The dependency key.</value>
    </member>
    <member name="P:Castle.Core.DependencyModel.TargetType">
      <summary>
            Gets the type of the target.
            </summary>
      <value>The type of the target.</value>
    </member>
    <member name="P:Castle.Core.DependencyModel.IsOptional">
      <summary>
            Gets or sets whether this dependency is optional.
            </summary>
      <value>
        <c>true</c> if this dependency is optional; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Castle.Core.DependencyModelCollection">
      <summary>
            Collection of <see cref="T:Castle.Core.DependencyModel" />.
            </summary>
    </member>
    <member name="M:Castle.Core.DependencyModelCollection.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.DependencyModelCollection" /> class.
            </summary>
    </member>
    <member name="M:Castle.Core.DependencyModelCollection.#ctor(Castle.Core.DependencyModelCollection)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.DependencyModelCollection" /> class.
            </summary>
      <param name="dependencies">The dependencies.</param>
    </member>
    <member name="M:Castle.Core.DependencyModelCollection.#ctor(Castle.Core.DependencyModel[])">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.DependencyModelCollection" /> class.
            </summary>
      <param name="dependencies">The dependencies.</param>
    </member>
    <member name="M:Castle.Core.DependencyModelCollection.Add(Castle.Core.DependencyModel)">
      <summary>
            Adds the specified model.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.Core.DependencyModelCollection.Remove(Castle.Core.DependencyModel)">
      <summary>
            Removes the specified model.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="M:Castle.Core.DependencyModelCollection.Clear">
      <summary>
            Clears this instance.
            </summary>
    </member>
    <member name="M:Castle.Core.DependencyModelCollection.Contains(Castle.Core.DependencyModel)">
      <summary>
            Determines whether this collection contains the the specified model.
            </summary>
      <param name="model">The model.</param>
      <returns>
        <c>true</c> if the collection contains the specified model; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Castle.Core.InterceptorReference">
      <summary>
            Represents an reference to a Interceptor component.
            </summary>
    </member>
    <member name="M:Castle.Core.InterceptorReference.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.InterceptorReference" /> class.
            </summary>
      <param name="componentKey">The component key.</param>
    </member>
    <member name="M:Castle.Core.InterceptorReference.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.InterceptorReference" /> class.
            </summary>
      <param name="serviceType">Type of the service.</param>
    </member>
    <member name="P:Castle.Core.InterceptorReference.ServiceType">
      <summary>
            Gets the type of the service.
            </summary>
      <value>The type of the service.</value>
    </member>
    <member name="P:Castle.Core.InterceptorReference.ComponentKey">
      <summary>
            Gets the interceptor component key.
            </summary>
      <value>The component key.</value>
    </member>
    <member name="P:Castle.Core.InterceptorReference.ReferenceType">
      <summary>
            Gets the type of the reference.
            </summary>
      <value>The type of the reference.</value>
    </member>
    <member name="T:Castle.Core.InterceptorReferenceCollection">
      <summary>
            Collection of <see cref="T:Castle.Core.InterceptorReference" /></summary>
    </member>
    <member name="M:Castle.Core.InterceptorReferenceCollection.Add(Castle.Core.InterceptorReference)">
      <summary>
            Adds the specified interceptor.
            </summary>
      <param name="interceptor">The interceptor.</param>
    </member>
    <member name="M:Castle.Core.InterceptorReferenceCollection.AddFirst(Castle.Core.InterceptorReference)">
      <summary>
            Adds the the specified interceptor as the first.
            </summary>
      <param name="interceptor">The interceptor.</param>
    </member>
    <member name="M:Castle.Core.InterceptorReferenceCollection.AddLast(Castle.Core.InterceptorReference)">
      <summary>
            Adds the the specified interceptor as the last.
            </summary>
      <param name="interceptor">The interceptor.</param>
    </member>
    <member name="M:Castle.Core.InterceptorReferenceCollection.Insert(System.Int32,Castle.Core.InterceptorReference)">
      <summary>
            Inserts the specified interceptor at the specified index.
            </summary>
      <param name="index">The index.</param>
      <param name="interceptor">The interceptor.</param>
    </member>
    <member name="M:Castle.Core.InterceptorReferenceCollection.CopyTo(System.Array,System.Int32)">
      <summary>
            When implemented by a class, copies the elements of
            the <see cref="T:System.Collections.ICollection" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
      <param name="index">The zero-based index in <paramref name="array" /> at which copying begins.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> is <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is less than zero.</exception>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="array" /> is multidimensional.</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than the length of <paramref name="array" />.</para>
        <para>-or-</para>
        <para>The number of elements in the source <see cref="T:System.Collections.ICollection" /> is greater than the available space from <paramref name="index" /> to the end of the destination <paramref name="array" />.</para>
      </exception>
      <exception cref="T:System.InvalidCastException">The type of the source <see cref="T:System.Collections.ICollection" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</exception>
    </member>
    <member name="M:Castle.Core.InterceptorReferenceCollection.GetEnumerator">
      <summary>
            Returns an enumerator that can iterate through a collection.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" />
            that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="P:Castle.Core.InterceptorReferenceCollection.HasInterceptors">
      <summary>
            Gets a value indicating whether this instance has interceptors.
            </summary>
      <value>
        <c>true</c> if this instance has interceptors; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Castle.Core.InterceptorReferenceCollection.Count">
      <summary>
            Gets the number of
            elements contained in the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Core.InterceptorReferenceCollection.SyncRoot">
      <summary>
            Gets an object that
            can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Core.InterceptorReferenceCollection.IsSynchronized">
      <summary>
            Gets a value
            indicating whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized
            (thread-safe).
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Castle.Core.LifecycleStepCollection">
      <summary>
            Represents a collection of ordered lifecycle steps.
            </summary>
    </member>
    <member name="M:Castle.Core.LifecycleStepCollection.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.LifecycleStepCollection" /> class.
            </summary>
    </member>
    <member name="M:Castle.Core.LifecycleStepCollection.GetCommissionSteps">
      <summary>
            Returns all steps for the commission phase
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.LifecycleStepCollection.GetDecommissionSteps">
      <summary>
            Returns all steps for the decommission phase
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.LifecycleStepCollection.Add(Castle.Core.LifecycleStepType,System.Object)">
      <summary>
            Adds a step to the commission or decomission phases.
            </summary>
      <param name="type">
      </param>
      <param name="stepImplementation">
      </param>
    </member>
    <member name="M:Castle.Core.LifecycleStepCollection.CopyTo(System.Array,System.Int32)">
      <summary>
            Copies the elements of
            the <see cref="T:System.Collections.ICollection" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
      <param name="index">The zero-based index in <paramref name="array" /> at which copying begins.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> is <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is less than zero.</exception>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="array" /> is multidimensional.</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than the length of <paramref name="array" />.</para>
        <para>-or-</para>
        <para>The number of elements in the source <see cref="T:System.Collections.ICollection" /> is greater than the available space from <paramref name="index" /> to the end of the destination <paramref name="array" />.</para>
      </exception>
      <exception cref="T:System.InvalidCastException">The type of the source <see cref="T:System.Collections.ICollection" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</exception>
    </member>
    <member name="M:Castle.Core.LifecycleStepCollection.GetEnumerator">
      <summary>
            Returns an enumerator that can iterate through a collection.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" />
            that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="P:Castle.Core.LifecycleStepCollection.HasCommissionSteps">
      <summary>
            Gets a value indicating whether this instance has commission steps.
            </summary>
      <value>
        <c>true</c> if this instance has commission steps; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Castle.Core.LifecycleStepCollection.HasDecommissionSteps">
      <summary>
            Gets a value indicating whether this instance has decommission steps.
            </summary>
      <value>
        <c>true</c> if this instance has decommission steps; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Castle.Core.LifecycleStepCollection.Count">
      <summary>
            Gets the number of
            elements contained in the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Core.LifecycleStepCollection.SyncRoot">
      <summary>
            Gets an object that
            can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Core.LifecycleStepCollection.IsSynchronized">
      <summary>
            Gets a value
            indicating whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized
            (thread-safe).
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Castle.Core.MethodMetaModel">
      <summary>
            Represents meta information associated with a method
            (not yet defined)
            </summary>
    </member>
    <member name="M:Castle.Core.MethodMetaModel.#ctor(Castle.Core.Configuration.IConfiguration)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.MethodMetaModel" /> class.
            </summary>
      <param name="configNode">The config node.</param>
    </member>
    <member name="P:Castle.Core.MethodMetaModel.ConfigNode">
      <summary>
            Gets the config node.
            </summary>
      <value>The config node.</value>
    </member>
    <member name="T:Castle.Core.MethodMetaModelCollection">
      <summary>
            Collection of <see cref="T:Castle.Core.MethodMetaModel" /></summary>
    </member>
    <member name="M:Castle.Core.MethodMetaModelCollection.Add(Castle.Core.MethodMetaModel)">
      <summary>
            Adds the specified model.
            </summary>
      <param name="model">The model.</param>
    </member>
    <member name="P:Castle.Core.MethodMetaModelCollection.MethodInfo2Model">
      <summary>
            Gets the method info2 model.
            </summary>
      <value>The method info2 model.</value>
    </member>
    <member name="T:Castle.Core.ParameterModel">
      <summary>
            Represents a parameter. Usually the parameter
            comes from the external world, ie, an external configuration.
            </summary>
    </member>
    <member name="M:Castle.Core.ParameterModel.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ParameterModel" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Castle.Core.ParameterModel.#ctor(System.String,Castle.Core.Configuration.IConfiguration)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ParameterModel" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="value">The value.</param>
    </member>
    <member name="P:Castle.Core.ParameterModel.Name">
      <summary>
            Gets the name.
            </summary>
      <value>The name.</value>
    </member>
    <member name="P:Castle.Core.ParameterModel.Value">
      <summary>
            Gets the value.
            </summary>
      <value>The value.</value>
    </member>
    <member name="P:Castle.Core.ParameterModel.ConfigValue">
      <summary>
            Gets the config value.
            </summary>
      <value>The config value.</value>
    </member>
    <member name="T:Castle.Core.ParameterModelCollection">
      <summary>
            Collection of <see cref="T:Castle.Core.ParameterModel" /></summary>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ParameterModelCollection" /> class.
            </summary>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.Add(System.String,System.String)">
      <summary>
            Adds the specified name.
            </summary>
      <param name="name">The name.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.Add(System.String,Castle.Core.Configuration.IConfiguration)">
      <summary>
            Adds the specified name.
            </summary>
      <param name="name">The name.</param>
      <param name="configNode">The config node.</param>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.Contains(System.Object)">
      <summary>
            Determines whether this collection contains the specified key.
            </summary>
      <param name="key">The key.</param>
      <returns>
        <c>true</c> if yes; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.Add(System.Object,System.Object)">
      <summary>
            Adds the specified key.
            </summary>
      <remarks>
            Not implemented
            </remarks>
      <param name="key">The key.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.Clear">
      <summary>
            Clears this instance.
            </summary>
      <remarks>
            Not implemented
            </remarks>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.Remove(System.Object)">
      <summary>
            Removes the specified key.
            </summary>
      <param name="key">The key.</param>
      <remarks>
            Not implemented
            </remarks>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.CopyTo(System.Array,System.Int32)">
      <summary>
            Copy the content to the specified array
            </summary>
      <param name="array">target array</param>
      <param name="index">target index</param>
      <remarks>
            Not implemented
            </remarks>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.GetEnumerator">
      <summary>
            Returns an enumerator that can iterate through a collection.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" />
            that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="P:Castle.Core.ParameterModelCollection.Keys">
      <summary>
            Gets the keys.
            </summary>
      <value>The keys.</value>
      <remarks>
            Not implemented
            </remarks>
    </member>
    <member name="P:Castle.Core.ParameterModelCollection.Values">
      <summary>
            Gets the values.
            </summary>
      <value>The values.</value>
      <remarks>
            Not implemented
            </remarks>
    </member>
    <member name="P:Castle.Core.ParameterModelCollection.IsReadOnly">
      <summary>
            Gets a value indicating whether this instance is read only.
            </summary>
      <value>
        <c>true</c> if this instance is read only; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Castle.Core.ParameterModelCollection.IsFixedSize">
      <summary>
            Gets a value indicating whether this instance is fixed size.
            </summary>
      <value>
        <c>true</c> if this instance is fixed size; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Castle.Core.ParameterModelCollection.Item(System.Object)">
      <summary>
            Gets the <see cref="T:Castle.Core.ParameterModel" /> with the specified key.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Core.ParameterModelCollection.Count">
      <summary>
            Gets the count.
            </summary>
      <value>The count.</value>
    </member>
    <member name="P:Castle.Core.ParameterModelCollection.SyncRoot">
      <summary>
            Gets the sync root.
            </summary>
      <value>The sync root.</value>
    </member>
    <member name="P:Castle.Core.ParameterModelCollection.IsSynchronized">
      <summary>
            Gets a value indicating whether this instance is synchronized.
            </summary>
      <value>
        <c>true</c> if this instance is synchronized; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Castle.Core.PropertySet">
      <summary>
            Represents a property and the respective dependency.
            </summary>
    </member>
    <member name="M:Castle.Core.PropertySet.#ctor(System.Reflection.PropertyInfo,Castle.Core.DependencyModel)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.PropertySet" /> class.
            </summary>
      <param name="propertyInfo">The property info.</param>
      <param name="dependency">The dependency.</param>
    </member>
    <member name="P:Castle.Core.PropertySet.Property">
      <summary>
            Gets the property.
            </summary>
      <value>The property.</value>
    </member>
    <member name="P:Castle.Core.PropertySet.Dependency">
      <summary>
            Gets the dependency.
            </summary>
      <value>The dependency.</value>
    </member>
    <member name="T:Castle.Core.PropertySetCollection">
      <summary>
            Collection of <see cref="T:Castle.Core.PropertySet" /></summary>
    </member>
    <member name="M:Castle.Core.PropertySetCollection.Add(Castle.Core.PropertySet)">
      <summary>
            Adds the specified property.
            </summary>
      <param name="property">The property.</param>
    </member>
    <member name="M:Castle.Core.PropertySetCollection.Clear">
      <summary>
            Clears this instance.
            </summary>
    </member>
    <member name="M:Castle.Core.PropertySetCollection.FindByPropertyInfo(System.Reflection.PropertyInfo)">
      <summary>
            Finds a PropertySet the by PropertyInfo.
            </summary>
      <param name="info">The info.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.Resource.IResource">
      <summary>
            Represents a 'streamable' resource. Can
            be a file, a resource in an assembly.
            </summary>
    </member>
    <member name="M:Castle.Core.Resource.IResource.GetStreamReader">
      <summary>
            Returns a reader for the stream
            </summary>
      <remarks>
            It's up to the caller to dispose the reader.
            </remarks>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResource.GetStreamReader(System.Text.Encoding)">
      <summary>
            Returns a reader for the stream
            </summary>
      <remarks>
            It's up to the caller to dispose the reader.
            </remarks>
      <param name="encoding">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResource.CreateRelative(System.String)">
      <summary>
            Returns an instance of <see cref="T:Castle.Core.Resource.IResource" />
            created according to the <c>relativePath</c>
            using itself as the root.
            </summary>
      <param name="relativePath">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.Core.Resource.IResource.FileBasePath">
      <summary>
      </summary>
      <remarks>
            Only valid for resources that
            can be obtained through relative paths
            </remarks>
    </member>
    <member name="T:Castle.Core.Resource.AbstractStreamResource">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Core.Resource.AbstractStreamResource.StreamHideCloseDelegate">
      <summary>
            Do not allow closing and disposal of the 
            underlying <see cref="P:Castle.Core.Resource.AbstractStreamResource.Stream" />.
            </summary>
    </member>
    <member name="T:Castle.Core.Resource.IResourceFactory">
      <summary>
            Depicts the contract for resource factories.
            </summary>
    </member>
    <member name="M:Castle.Core.Resource.IResourceFactory.Accept(Castle.Core.Resource.CustomUri)">
      <summary>
            Used to check whether the resource factory
            is able to deal with the given resource
            identifier.
            </summary>
      <remarks>
            Implementors should return <c>true</c>
            only if the given identificator is supported
            by the resource factory
            </remarks>
      <param name="uri">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResourceFactory.Create(Castle.Core.Resource.CustomUri)">
      <summary>
            Creates an <see cref="T:Castle.Core.Resource.IResource" /> instance
            for the given resource identifier
            </summary>
      <param name="uri">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResourceFactory.Create(Castle.Core.Resource.CustomUri,System.String)">
      <summary>
            Creates an <see cref="T:Castle.Core.Resource.IResource" /> instance
            for the given resource identifier
            </summary>
      <param name="uri">
      </param>
      <param name="basePath">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.Resource.AssemblyResourceFactory">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Core.Resource.FileResource">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Core.Resource.FileResourceFactory">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Core.Resource.StaticContentResource">
      <summary>
            Adapts a static string content as an <see cref="T:Castle.Core.Resource.IResource" /></summary>
    </member>
    <member name="T:Castle.Core.Resource.UncResource">
      <summary>
            Enable access to files on network shares
            </summary>
    </member>
    <member name="T:Castle.Core.IServiceEnabledComponent">
      <summary>
            Defines that the implementation wants a 
            <see cref="T:System.IServiceProvider" /> in order to 
            access other components. The creator must be aware
            that the component might (or might not) implement 
            the interface.
            </summary>
      <remarks>
            Used by Castle Project components to, for example, 
            gather logging factories
            </remarks>
    </member>
    <member name="T:Castle.Core.IServiceProviderEx">
      <summary>
            Increments <c>IServiceProvider</c> with a generic service resolution operation.
            </summary>
    </member>
    <member name="T:Castle.Core.IServiceProviderExAccessor">
      <summary>
            This interface should be implemented by classes
            that are available in a bigger context, exposing
            the container to different areas in the same application.
            <para>
            For example, in Web application, the (global) HttpApplication
            subclasses should implement this interface to expose 
            the configured container
            </para></summary>
    </member>
    <member name="T:Castle.Core.Pair`2">
      <summary>
            General purpose class to represent a standard pair of values. 
            </summary>
      <typeparam name="TFirst">Type of the first value</typeparam>
      <typeparam name="TSecond">Type of the second value</typeparam>
    </member>
    <member name="M:Castle.Core.Pair`2.#ctor(`0,`1)">
      <summary>
            Constructs a pair with its values
            </summary>
      <param name="first">
      </param>
      <param name="second">
      </param>
    </member>
  </members>
</doc>